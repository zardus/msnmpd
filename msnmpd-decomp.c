/* This file was generated by the Hex-Rays decompiler version 9.0.0.240807.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_2020();
void sub_2030();
void sub_2040();
void sub_2050();
void sub_2060();
void sub_2070();
void sub_2080();
void sub_2090();
void sub_20A0();
void sub_20B0();
void sub_20C0();
void sub_20D0();
void sub_20E0();
void sub_20F0();
void sub_2100();
void sub_2110();
void sub_2120();
void sub_2130();
void sub_2140();
void sub_2150();
void sub_2160();
void sub_2170();
void sub_2180();
void sub_2190();
void sub_21A0();
void sub_21B0();
void sub_21C0();
void sub_21D0();
void sub_21E0();
void sub_21F0();
void sub_2200();
void sub_2210();
void sub_2220();
void sub_2230();
void sub_2240();
void sub_2250();
void sub_2260();
void sub_2270();
void sub_2280();
void sub_2290();
void sub_22A0();
void sub_22B0();
void sub_22C0();
void sub_22D0();
void sub_22E0();
void sub_22F0();
void sub_2300();
void sub_2310();
void sub_2320();
void sub_2330();
void sub_2340();
void sub_2350();
void sub_2360();
void sub_2370();
void sub_2380();
void sub_2390();
void sub_23A0();
void sub_23B0();
void sub_23C0();
void sub_23D0();
void sub_23E0();
void sub_23F0();
void sub_2400();
void sub_2410();
void sub_2420();
void sub_2430();
void sub_2440();
void sub_2450();
void sub_2460();
void sub_2470();
void sub_2480();
void sub_2490();
void sub_24A0();
void sub_24B0();
void sub_24C0();
void sub_24D0();
// int _cxa_finalize(void *);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...); weak
// void free(void *ptr);
// int utimensat(int fd, const char *path, const struct timespec times[2], int flags);
// void closelog(void);
// int *__errno_location(void);
// int unlink(const char *name);
// int puts(const char *s);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// double strtod(const char *nptr, char **endptr);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __pid_t getpid(void);
// int fclose(FILE *stream);
// size_t strlen(const char *s);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// __int64 __fastcall __fdelt_chk(_QWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// char *strrchr(const char *s, int c);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void *memset(void *s, int c, size_t n);
// __uid_t geteuid(void);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *fgets(char *s, int n, FILE *stream);
// __int64 __asprintf_chk(_QWORD, _QWORD, const char *, ...); weak
// int strcmp(const char *s1, const char *s2);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// struct passwd *getpwnam(const char *name);
// __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int sigemptyset(sigset_t *set);
// unsigned int if_nametoindex(const char *ifname);
// void *memcpy(void *dest, const void *src, size_t n);
// struct group *getgrnam(const char *name);
// time_t time(time_t *timer);
// __int64 __fastcall __isoc23_strtol(_QWORD, _QWORD, _QWORD); weak
// int statfs(const char *file, struct statfs *buf);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// void *malloc(size_t size);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int fflush(FILE *stream);
// int getifaddrs(struct ifaddrs **ifap);
// int listen(int fd, int n);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int daemon(int nochdir, int noclose);
// __int64 __fastcall __vsnprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void *realloc(void *ptr, size_t size);
// __int64 __printf_chk(_QWORD, const char *, ...); weak
// void freeifaddrs(struct ifaddrs *ifa);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// void *memmove(void *dest, const void *src, size_t n);
// __int64 __syslog_chk(_QWORD, _QWORD, const char *, ...); weak
// int setgid(__gid_t gid);
// int access(const char *name, int type);
// FILE *fopen(const char *filename, const char *modes);
// char *strtok(char *s, const char *delim);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
// void openlog(const char *ident, int option, int facility);
// int gethostname(char *name, size_t len);
// void __noreturn exit(int status);
// __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...); weak
// int setuid(__uid_t uid);
// char *strdup(const char *s);
// char *strerror(int errnum);
// char *strstr(const char *haystack, const char *needle);
// const unsigned __int16 **__ctype_b_loc(void);
// int socket(int domain, int type, int protocol);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *sub_3EC0();
__int64 sub_3EF0(void); // weak
void *sub_3F30();
__int64 sub_3F70();
void sub_3F80();
__int64 __fastcall sub_3F90(unsigned int a1);
__int64 sub_3FF0(void); // weak
__int64 sub_4090(void); // weak
unsigned __int64 __fastcall sub_4110(_DWORD *a1);
unsigned __int64 __fastcall sub_4210(__int64 a1);
unsigned __int64 __fastcall sub_4340(_OWORD *a1);
unsigned __int64 __fastcall sub_4440(__int64 a1);
unsigned __int64 __fastcall sub_4520(_QWORD *a1);
unsigned __int64 __fastcall sub_4670(_OWORD *a1);
unsigned __int64 __fastcall sub_4730(_OWORD *a1);
unsigned __int64 __fastcall sub_49A0(__int64 a1);
__int64 __fastcall compar(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_4CD0(__int64 a1);
__int64 __fastcall sub_4DB0(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_4EA0(__int64 a1, int a2);
__m128i *__fastcall sub_4FE0(const __m128i *a1, unsigned int a2, unsigned int a3, int a4);
__int64 __fastcall sub_5190(__int64 a1, int a2, __int64 a3);
void __fastcall sub_5690(__int64 a1, int a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_58B0(const __m128i *a1, unsigned int a2, unsigned int a3, unsigned __int64 *a4);
__int64 __fastcall sub_5A50(const __m128i *a1, unsigned int a2, unsigned int a3, unsigned __int64 *a4, int a5, __int64 a6);
__int64 __fastcall sub_5B00(const __m128i *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5);
__int64 sub_5C00(void); // weak
__int64 __fastcall sub_71A0(int a1);
_QWORD *__fastcall sub_8640(_QWORD *s2, unsigned __int64 *a2);
_DWORD *__fastcall sub_86C0(__int64 a1);
__int64 __fastcall sub_8740(__int64 a1, unsigned __int64 a2, unsigned __int64 *a3, _DWORD *a4, _QWORD *a5);
_BYTE *__fastcall sub_88B0(_BYTE *a1, unsigned int a2);
__int64 __fastcall sub_8930(__int64 a1);
__int64 __fastcall sub_8A10(__int64 a1);
int __fastcall sub_A870(const char *a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_AAB0(const char *a1, const char *a2);
size_t __fastcall sub_AB50(char *a1, const char *a2, _DWORD *a3, int a4);
__int64 sub_AC30(_DWORD *a1, __int64 a2, ...);
char *__fastcall sub_AD90(__int64 a1);
int *__fastcall sub_AE10(char *a1);
__int64 __fastcall sub_AEE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_AF60(const char *a1, const char *a2, __int64 a3, int a4);
__int64 sub_B000(void); // weak
__int64 __fastcall sub_B070(char *s2); // idb
__int64 sub_B0F0(unsigned int a1, int a2, __int64 a3, ...);
void *__fastcall sub_B440(size_t a1);
__int64 __fastcall sub_B480(const char *a1, void *a2, __int64 a3);
__int64 __fastcall sub_B530(__time_t *a1, struct timeval *a2);
void sub_B640();
__int64 __fastcall sub_B6A0(const char *a1);
int __fastcall sub_B8E0(void (*a1)(void *));
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
// extern _UNKNOWN __memcpy_chk; weak
_UNKNOWN main;
_DWORD dword_D53C[9] = { 0, 1, 5, 15, 0, 0, 0, 0, 0 }; // weak
__m128i xmmword_D560[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 4, 0, 0, 0, 1, 0, 0, 0, -27, 7, 0, 0, 11, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 8, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D5C0[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 4, 0, 0, 0, 1, 0, 0, 0, -27, 7, 0, 0, 10, 0, 0, 0 } },
  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 9, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D620[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 4, 0, 0, 0, 1, 0, 0, 0, -27, 7, 0, 0, 9, 0, 0, 0 } },
  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 9, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D680[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 4, 0, 0, 0, 1, 0, 0, 0, -27, 7, 0, 0, 4, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 8, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D6E0[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 31, 0, 0, 0, 1, 0, 0, 0 } },
  { { 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 10, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D740[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 25, 0, 0, 0, 1, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D7A0[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D800[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D860[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D8C0[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0 } },
  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 9, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D920[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_D980[6] =
{
  { { 1, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0 } },
  { { 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__int128 xmmword_D9E0 = 0x1000000060000000300000001LL; // weak
__int128 xmmword_D9F0 = 0x14000000040000000100000002LL; // weak
struct option longopts = { "use-ipv4", 0, &dword_0, 52 }; // idb
__m128i off_FAE0 = { { 4, -38, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 } }; // weak
__m128i off_FB00 = { { 7, -38, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 } }; // weak
__m128i off_FB20 = { { 10, -38, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 } }; // weak
__m128i off_FB40 = { { 13, -38, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 } }; // weak
__int128 in6addr_any = 0LL; // weak
void *lpdso_handle = &lpdso_handle; // idb
char *off_101A0 = "alert"; // weak
char *off_101B0 = "crit"; // weak
int dword_10270 = -1; // idb
int fd = -1; // idb
__int16 word_10278 = 161; // weak
__int16 word_1027A = 161; // weak
__int64 qword_10280 = 1LL; // weak
int dword_10288 = 5; // weak
int dword_1028C = 1; // weak
int dword_10290 = 1; // weak
int dword_10294 = 2; // weak
char *off_102A0 = "/"; // weak
char *off_102C0 = "/var/run"; // weak
_UNKNOWN unk_102C8; // weak
char *optarg; // idb
__int64 stderr; // weak
char byte_10308; // weak
int dword_1030C; // weak
int dword_10320[16]; // weak
__int64 qword_10360; // weak
_DWORD dword_10380[44836]; // weak
_UNKNOWN unk_3C010; // weak
__int64 qword_4C380; // weak
_QWORD qword_4C3A0[16]; // weak
__int64 qword_4C420; // weak
int dword_4C428; // weak
__int128 xmmword_4C42C; // weak
__int16 word_4C43C; // weak
_UNKNOWN unk_4C43E; // weak
size_t n; // idb
int dword_4CC48; // weak
size_t nmemb; // idb
_QWORD qword_4CC60[8]; // weak
char *name; // idb
__int64 qword_4CCA8; // weak
__int64 qword_4CCB0; // weak
__int64 qword_4CCB8; // weak
__int64 qword_4CCC0; // weak
__int64 qword_4CCC8; // weak
char *s1; // idb
char *ident; // idb
int dword_4CCE0; // weak
int dword_4CCE4; // weak
int dword_4CCE8; // weak
int dword_4CD00[]; // weak
int dword_4CD04; // weak
__int64 qword_4CD50; // weak
char byte_4CD60[208]; // weak
__int64 qword_4CE30; // weak
int dword_4CE38; // weak
char *ptr; // idb


//----- (0000000000002000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 4D0B8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000002020) ----------------------------------------------------
void sub_2020()
{
  JUMPOUT(0LL);
}
// 2026: control flows out of bounds to 0

//----- (0000000000002030) ----------------------------------------------------
void sub_2030()
{
  sub_2020();
}

//----- (0000000000002040) ----------------------------------------------------
void sub_2040()
{
  sub_2020();
}

//----- (0000000000002050) ----------------------------------------------------
void sub_2050()
{
  sub_2020();
}

//----- (0000000000002060) ----------------------------------------------------
void sub_2060()
{
  sub_2020();
}

//----- (0000000000002070) ----------------------------------------------------
void sub_2070()
{
  sub_2020();
}

//----- (0000000000002080) ----------------------------------------------------
void sub_2080()
{
  sub_2020();
}

//----- (0000000000002090) ----------------------------------------------------
void sub_2090()
{
  sub_2020();
}

//----- (00000000000020A0) ----------------------------------------------------
void sub_20A0()
{
  sub_2020();
}

//----- (00000000000020B0) ----------------------------------------------------
void sub_20B0()
{
  sub_2020();
}

//----- (00000000000020C0) ----------------------------------------------------
void sub_20C0()
{
  sub_2020();
}

//----- (00000000000020D0) ----------------------------------------------------
void sub_20D0()
{
  sub_2020();
}

//----- (00000000000020E0) ----------------------------------------------------
void sub_20E0()
{
  sub_2020();
}

//----- (00000000000020F0) ----------------------------------------------------
void sub_20F0()
{
  sub_2020();
}

//----- (0000000000002100) ----------------------------------------------------
void sub_2100()
{
  sub_2020();
}

//----- (0000000000002110) ----------------------------------------------------
void sub_2110()
{
  sub_2020();
}

//----- (0000000000002120) ----------------------------------------------------
void sub_2120()
{
  sub_2020();
}

//----- (0000000000002130) ----------------------------------------------------
void sub_2130()
{
  sub_2020();
}

//----- (0000000000002140) ----------------------------------------------------
void sub_2140()
{
  sub_2020();
}

//----- (0000000000002150) ----------------------------------------------------
void sub_2150()
{
  sub_2020();
}

//----- (0000000000002160) ----------------------------------------------------
void sub_2160()
{
  sub_2020();
}

//----- (0000000000002170) ----------------------------------------------------
void sub_2170()
{
  sub_2020();
}

//----- (0000000000002180) ----------------------------------------------------
void sub_2180()
{
  sub_2020();
}

//----- (0000000000002190) ----------------------------------------------------
void sub_2190()
{
  sub_2020();
}

//----- (00000000000021A0) ----------------------------------------------------
void sub_21A0()
{
  sub_2020();
}

//----- (00000000000021B0) ----------------------------------------------------
void sub_21B0()
{
  sub_2020();
}

//----- (00000000000021C0) ----------------------------------------------------
void sub_21C0()
{
  sub_2020();
}

//----- (00000000000021D0) ----------------------------------------------------
void sub_21D0()
{
  sub_2020();
}

//----- (00000000000021E0) ----------------------------------------------------
void sub_21E0()
{
  sub_2020();
}

//----- (00000000000021F0) ----------------------------------------------------
void sub_21F0()
{
  sub_2020();
}

//----- (0000000000002200) ----------------------------------------------------
void sub_2200()
{
  sub_2020();
}

//----- (0000000000002210) ----------------------------------------------------
void sub_2210()
{
  sub_2020();
}

//----- (0000000000002220) ----------------------------------------------------
void sub_2220()
{
  sub_2020();
}

//----- (0000000000002230) ----------------------------------------------------
void sub_2230()
{
  sub_2020();
}

//----- (0000000000002240) ----------------------------------------------------
void sub_2240()
{
  sub_2020();
}

//----- (0000000000002250) ----------------------------------------------------
void sub_2250()
{
  sub_2020();
}

//----- (0000000000002260) ----------------------------------------------------
void sub_2260()
{
  sub_2020();
}

//----- (0000000000002270) ----------------------------------------------------
void sub_2270()
{
  sub_2020();
}

//----- (0000000000002280) ----------------------------------------------------
void sub_2280()
{
  sub_2020();
}

//----- (0000000000002290) ----------------------------------------------------
void sub_2290()
{
  sub_2020();
}

//----- (00000000000022A0) ----------------------------------------------------
void sub_22A0()
{
  sub_2020();
}

//----- (00000000000022B0) ----------------------------------------------------
void sub_22B0()
{
  sub_2020();
}

//----- (00000000000022C0) ----------------------------------------------------
void sub_22C0()
{
  sub_2020();
}

//----- (00000000000022D0) ----------------------------------------------------
void sub_22D0()
{
  sub_2020();
}

//----- (00000000000022E0) ----------------------------------------------------
void sub_22E0()
{
  sub_2020();
}

//----- (00000000000022F0) ----------------------------------------------------
void sub_22F0()
{
  sub_2020();
}

//----- (0000000000002300) ----------------------------------------------------
void sub_2300()
{
  sub_2020();
}

//----- (0000000000002310) ----------------------------------------------------
void sub_2310()
{
  sub_2020();
}

//----- (0000000000002320) ----------------------------------------------------
void sub_2320()
{
  sub_2020();
}

//----- (0000000000002330) ----------------------------------------------------
void sub_2330()
{
  sub_2020();
}

//----- (0000000000002340) ----------------------------------------------------
void sub_2340()
{
  sub_2020();
}

//----- (0000000000002350) ----------------------------------------------------
void sub_2350()
{
  sub_2020();
}

//----- (0000000000002360) ----------------------------------------------------
void sub_2360()
{
  sub_2020();
}

//----- (0000000000002370) ----------------------------------------------------
void sub_2370()
{
  sub_2020();
}

//----- (0000000000002380) ----------------------------------------------------
void sub_2380()
{
  sub_2020();
}

//----- (0000000000002390) ----------------------------------------------------
void sub_2390()
{
  sub_2020();
}

//----- (00000000000023A0) ----------------------------------------------------
void sub_23A0()
{
  sub_2020();
}

//----- (00000000000023B0) ----------------------------------------------------
void sub_23B0()
{
  sub_2020();
}

//----- (00000000000023C0) ----------------------------------------------------
void sub_23C0()
{
  sub_2020();
}

//----- (00000000000023D0) ----------------------------------------------------
void sub_23D0()
{
  sub_2020();
}

//----- (00000000000023E0) ----------------------------------------------------
void sub_23E0()
{
  sub_2020();
}

//----- (00000000000023F0) ----------------------------------------------------
void sub_23F0()
{
  sub_2020();
}

//----- (0000000000002400) ----------------------------------------------------
void sub_2400()
{
  sub_2020();
}

//----- (0000000000002410) ----------------------------------------------------
void sub_2410()
{
  sub_2020();
}

//----- (0000000000002420) ----------------------------------------------------
void sub_2420()
{
  sub_2020();
}

//----- (0000000000002430) ----------------------------------------------------
void sub_2430()
{
  sub_2020();
}

//----- (0000000000002440) ----------------------------------------------------
void sub_2440()
{
  sub_2020();
}

//----- (0000000000002450) ----------------------------------------------------
void sub_2450()
{
  sub_2020();
}

//----- (0000000000002460) ----------------------------------------------------
void sub_2460()
{
  sub_2020();
}

//----- (0000000000002470) ----------------------------------------------------
void sub_2470()
{
  sub_2020();
}

//----- (0000000000002480) ----------------------------------------------------
void sub_2480()
{
  sub_2020();
}

//----- (0000000000002490) ----------------------------------------------------
void sub_2490()
{
  sub_2020();
}

//----- (00000000000024A0) ----------------------------------------------------
void sub_24A0()
{
  sub_2020();
}

//----- (00000000000024B0) ----------------------------------------------------
void sub_24B0()
{
  sub_2020();
}

//----- (00000000000024C0) ----------------------------------------------------
void sub_24C0()
{
  sub_2020();
}

//----- (00000000000024D0) ----------------------------------------------------
void sub_24D0()
{
  sub_2020();
}

//----- (00000000000029A0) ----------------------------------------------------
__int64 __fastcall main(int a1, const char **a2, char **a3)
{
  const char *v3; // r12
  char *v4; // rax
  int v5; // eax
  size_t v7; // rax
  const char **v8; // r13
  const char *v9; // rcx
  size_t v10; // rax
  int v11; // eax
  int v12; // edi
  socklen_t v13; // edx
  int v14; // edi
  socklen_t v15; // edx
  char *v16; // r12
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // rax
  int v20; // ecx
  int v21; // eax
  unsigned __int64 v22; // r14
  int i; // r13d
  __int64 v24; // rax
  int v25; // ecx
  __int64 v26; // rdi
  __int64 v27; // rax
  int v28; // eax
  int v29; // r12d
  __time_t v30; // rcx
  __suseconds_t v31; // rax
  unsigned __int64 v32; // rbp
  __int64 *v33; // r14
  __int64 v34; // rax
  __int64 v35; // r13
  unsigned __int64 v36; // r13
  __int64 v37; // rdi
  __int64 v38; // rax
  int v39; // edi
  __m128i v40; // xmm2
  __int64 v41; // rax
  int v42; // eax
  int v43; // edi
  __int16 v44; // ax
  size_t v45; // rdx
  unsigned __int64 v46; // r14
  _DWORD *v47; // rdi
  __int64 v48; // rbp
  __int64 v49; // rax
  unsigned __int64 v50; // r13
  int v51; // eax
  int v52; // r13d
  __int64 v53; // rax
  char *v54; // r14
  __m128i v55; // xmm6
  __int16 v56; // ax
  time_t v57; // rax
  __m128i v58; // xmm5
  ssize_t v59; // r12
  __m128i v60; // xmm4
  ssize_t v61; // r13
  int *v62; // rax
  int *v63; // rax
  __int64 v64; // rax
  int *v65; // rax
  int *v66; // rax
  int *v67; // rax
  const char *v68; // rcx
  int v69; // r9d
  int *v70; // rax
  int *v71; // rax
  int *v72; // rax
  int *v73; // rax
  const char *v74; // rdi
  int *v75; // rbx
  struct passwd *v76; // rbp
  const char *v77; // rdi
  struct group *v78; // rax
  int *v79; // rax
  int *v80; // rax
  int *v81; // rax
  int *v82; // rax
  int *v83; // rax
  int *v84; // rax
  int *v85; // rax
  int *v86; // rax
  char *s; // [rsp+8h] [rbp-310h]
  char *sa; // [rsp+8h] [rbp-310h]
  int sb; // [rsp+8h] [rbp-310h]
  char *sc; // [rsp+8h] [rbp-310h]
  char *s2; // [rsp+10h] [rbp-308h]
  int readfds; // [rsp+18h] [rbp-300h]
  size_t n; // [rsp+20h] [rbp-2F8h]
  int v94; // [rsp+34h] [rbp-2E4h] BYREF
  int longind; // [rsp+38h] [rbp-2E0h] BYREF
  socklen_t addr_len; // [rsp+3Ch] [rbp-2DCh] BYREF
  timeval tv; // [rsp+40h] [rbp-2D8h] BYREF
  struct timeval v98; // [rsp+50h] [rbp-2C8h] BYREF
  struct timeval v99; // [rsp+60h] [rbp-2B8h] BYREF
  struct sockaddr addr[4]; // [rsp+70h] [rbp-2A8h] BYREF
  struct sockaddr cp[2]; // [rsp+B0h] [rbp-268h] BYREF
  char optval[48]; // [rsp+D0h] [rbp-248h] BYREF
  fd_set v103; // [rsp+100h] [rbp-218h] BYREF
  fd_set v104; // [rsp+180h] [rbp-198h] BYREF
  sigaction act; // [rsp+200h] [rbp-118h] BYREF
  char buf[16]; // [rsp+2A0h] [rbp-78h] BYREF
  _BYTE v107[30]; // [rsp+2B0h] [rbp-68h] BYREF
  unsigned __int64 v108; // [rsp+2D8h] [rbp-40h]

  v3 = *a2;
  v108 = __readfsqword(0x28u);
  longind = 1;
  v4 = strrchr(v3, 47);
  if ( v4 )
    v3 = v4 + 1;
  ident = (char *)v3;
LABEL_4:
  while ( 1 )
  {
    v5 = getopt_long(a1, (char *const *)a2, "ac:C:d:D:hi:l:L:np:P:st:u:vV:I:46", &longopts, &longind);
    v94 = v5;
    if ( v5 == -1 )
      break;
    switch ( v5 )
    {
      case '4':
        dword_10294 = 2;
        continue;
      case '6':
        dword_10294 = 10;
        continue;
      case 'C':
        qword_4CCB0 = (__int64)optarg;
        continue;
      case 'D':
        qword_4CCC0 = (__int64)optarg;
        continue;
      case 'I':
        qword_4CCA8 = (__int64)strdup(optarg);
        continue;
      case 'L':
        qword_4CCB8 = (__int64)optarg;
        continue;
      case 'P':
        word_10278 = __isoc23_strtol(optarg, 0LL, 10LL);
        continue;
      case 'V':
        qword_4CCC8 = (__int64)optarg;
        continue;
      case 'a':
        dword_4CCE8 = 1;
        continue;
      case 'c':
        s1 = optarg;
        continue;
      case 'd':
        qword_10280 = (int)sub_AF60(optarg, ",:;", (__int64)&off_102A0, 4);
        continue;
      case 'h':
        return sub_3F90(0);
      case 'i':
        nmemb = (int)sub_AF60(optarg, ",;", (__int64)qword_4CC60, 8);
        continue;
      case 'l':
        s2 = optarg;
        s = off_101A0;
        if ( !off_101A0 )
          goto LABEL_35;
        v7 = strlen(optarg);
        v8 = (const char **)&off_101B0;
        v9 = s;
        n = v7;
        readfds = 0;
        break;
      case 'n':
        dword_1028C = 0;
        continue;
      case 'p':
        word_1027A = __isoc23_strtol(optarg, 0LL, 10LL);
        continue;
      case 's':
        dword_4CCE4 = 1;
        continue;
      case 't':
        dword_10290 = __isoc23_strtol(optarg, 0LL, 10LL);
        continue;
      case 'u':
        name = optarg;
        continue;
      case 'v':
        puts("v1.6");
        return 0LL;
      default:
        return sub_3F90(1u);
    }
    do
    {
      sa = (char *)v9;
      v10 = strlen(v9);
      if ( v10 > n )
        v10 = n;
      if ( !strncasecmp(sa, s2, v10) )
      {
        dword_10288 = (int)(&off_101A0)[2 * readfds + 1];
        goto LABEL_4;
      }
      v9 = *v8;
      v8 += 2;
      ++readfds;
    }
    while ( v9 );
LABEL_35:
    v11 = __isoc23_strtol(s2, 0LL, 10LL);
    if ( v11 == -1 )
      return sub_3F90(1u);
    dword_10288 = v11;
  }
  if ( dword_4CCE4 )
    openlog(ident, 3, 24);
  sub_B0F0(5u, 0, (__int64)"mini-snmpd v1.6 starting");
  if ( dword_1028C )
  {
    sub_B0F0(7u, 0, (__int64)"Daemonizing ...");
    if ( daemon(0, 0) == -1 )
    {
      v72 = __errno_location();
      sub_B0F0(3u, *v72, (__int64)"Failed daemonizing");
      return 1LL;
    }
  }
  if ( !s1 )
    s1 = "public";
  if ( !qword_4CCC8 )
    qword_4CCC8 = (__int64)".1.3.6.1.4.1";
  if ( !qword_4CCC0 )
    qword_4CCC0 = (__int64)"";
  if ( !qword_4CCB8 )
    qword_4CCB8 = (__int64)"";
  if ( !qword_4CCB0 )
    qword_4CCB0 = (__int64)"";
  dword_10290 *= 100;
  if ( gettimeofday(&tv, 0LL) == -1 )
  {
    tv = 0LL;
    v99 = 0LL;
  }
  else
  {
    v99.tv_sec = dword_10290 / 100;
    v99.tv_usec = 10000 * (dword_10290 % 100);
  }
  if ( (unsigned int)sub_5C00() == -1 || (unsigned int)sub_71A0(1) == -1 )
LABEL_171:
    exit(2);
  act.sa_handler = (__sighandler_t)sub_3F80;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0x10000000;
  sigaction(15, &act, 0LL);
  sigaction(2, &act, 0LL);
  sigaction(1, &act, 0LL);
  v12 = dword_10294;
  if ( dword_10294 != 2 )
    v12 = 10;
  fd = socket(v12, 2, 0);
  if ( fd == -1 )
  {
    v81 = __errno_location();
    sub_B0F0(3u, *v81, (__int64)"could not create UDP socket");
    goto LABEL_171;
  }
  *(_WORD *)addr[0].sa_data = __ROL2__(word_1027A, 8);
  if ( dword_10294 == 2 )
  {
    v13 = 16;
    addr[0].sa_family = 2;
    *(_DWORD *)&addr[0].sa_data[2] = 0;
  }
  else
  {
    addr[0].sa_family = dword_10294;
    v13 = 28;
    *(__m128i *)&addr[0].sa_data[6] = _mm_loadu_si128((const __m128i *)&in6addr_any);
  }
  if ( bind(fd, addr, v13) == -1 )
  {
    v82 = __errno_location();
    sub_B0F0(3u, *v82, (__int64)"could not bind UDP socket to port %d", (unsigned __int16)word_1027A);
    goto LABEL_171;
  }
  if ( qword_4CCA8 )
  {
    snprintf(optval, 0x10uLL, "%s", (const char *)qword_4CCA8);
    if ( setsockopt(fd, 1, 25, optval, 0x28u) == -1 )
    {
      v86 = __errno_location();
      sub_B0F0(4u, *v86, (__int64)"could not bind UDP socket to device %s", qword_4CCA8);
LABEL_181:
      exit(2);
    }
  }
  v14 = dword_10294;
  if ( dword_10294 != 2 )
    v14 = 10;
  dword_10270 = socket(v14, 1, 0);
  if ( dword_10270 == -1 )
  {
    v85 = __errno_location();
    sub_B0F0(3u, *v85, (__int64)"could not create TCP socket");
    goto LABEL_171;
  }
  if ( qword_4CCA8 )
  {
    snprintf(optval, 0x10uLL, "%s", (const char *)qword_4CCA8);
    if ( setsockopt(dword_10270, 1, 25, optval, 0x28u) == -1 )
    {
      v84 = __errno_location();
      sub_B0F0(4u, *v84, (__int64)"could not bind TCP socket to device %s", qword_4CCA8);
      goto LABEL_181;
    }
  }
  v94 = 1;
  if ( setsockopt(dword_10270, 1, 2, &v94, 4u) == -1 )
  {
    v83 = __errno_location();
    sub_B0F0(4u, *v83, (__int64)"could not set SO_REUSEADDR on TCP socket");
    exit(2);
  }
  *(_WORD *)addr[0].sa_data = __ROL2__(word_1027A, 8);
  if ( dword_10294 == 2 )
  {
    v15 = 16;
    addr[0].sa_family = 2;
    *(_DWORD *)&addr[0].sa_data[2] = 0;
  }
  else
  {
    addr[0].sa_family = dword_10294;
    v15 = 28;
    *(__m128i *)&addr[0].sa_data[6] = _mm_loadu_si128((const __m128i *)&in6addr_any);
  }
  if ( bind(dword_10270, addr, v15) == -1 )
  {
    v80 = __errno_location();
    sub_B0F0(3u, *v80, (__int64)"could not bind TCP socket to port %d", (unsigned __int16)word_10278);
    goto LABEL_171;
  }
  if ( listen(dword_10270, 128) == -1 )
  {
    v79 = __errno_location();
    sub_B0F0(3u, *v79, (__int64)"could not prepare TCP socket for listening");
    goto LABEL_171;
  }
  if ( qword_4CCA8 )
    sub_B0F0(
      5u,
      0,
      (__int64)"Listening on port %d/udp and %d/tcp on interface %s",
      (unsigned __int16)word_1027A,
      (unsigned __int16)word_10278,
      (const char *)qword_4CCA8);
  else
    sub_B0F0(
      5u,
      0,
      (__int64)"Listening on port %d/udp and %d/tcp",
      (unsigned __int16)word_1027A,
      (unsigned __int16)word_10278);
  if ( name && !geteuid() )
  {
    v73 = __errno_location();
    v74 = name;
    *v73 = 0;
    v75 = v73;
    v76 = getpwnam(v74);
    if ( !v76 )
    {
      sub_B0F0(3u, *v75, (__int64)"Unable to get UID for user \"%s\"", name);
      goto LABEL_169;
    }
    v77 = name;
    *v75 = 0;
    v78 = getgrnam(v77);
    if ( !v78 )
    {
      sub_B0F0(3u, *v75, (__int64)"Unable to get GID for group \"%s\"", name);
      exit(2);
    }
    if ( setgid(v78->gr_gid) == -1 )
    {
      sub_B0F0(3u, *v75, (__int64)"Unable to set new group \"%s\"", name);
      goto LABEL_169;
    }
    if ( setuid(v76->pw_uid) == -1 )
    {
      sub_B0F0(3u, *v75, (__int64)"Unable to set new user \"%s\"", name);
      goto LABEL_169;
    }
    sub_B0F0(6u, 0, (__int64)"Successfully dropped privileges to %s:%s", name, name);
  }
  if ( (unsigned int)sub_B6A0(0LL) )
  {
    v71 = __errno_location();
    sub_B0F0(3u, *v71, (__int64)"Failed creating PID file");
  }
  if ( dword_4CCE0 )
    goto LABEL_113;
  do
  {
    v16 = (char *)qword_4C3A0;
    memset(&v103, 0, sizeof(v103));
    memset(&v104, 0, sizeof(v104));
    v17 = __fdelt_chk(fd);
    v18 = dword_10270;
    v103.fds_bits[v17] |= 1LL << fd;
    v19 = __fdelt_chk(v18);
    v20 = dword_10270;
    v103.fds_bits[v19] |= 1LL << dword_10270;
    v21 = fd;
    if ( v20 >= fd )
      v21 = v20;
    v22 = 0LL;
    for ( i = v21; v22 < qword_4C380; v16 += 8 )
    {
      v26 = *(int *)(*(_QWORD *)v16 + 8LL);
      if ( *(_DWORD *)(*(_QWORD *)v16 + 2088LL) )
      {
        v24 = __fdelt_chk(v26);
        v25 = *(_DWORD *)(*(_QWORD *)v16 + 8LL);
        v104.fds_bits[v24] |= 1LL << v25;
      }
      else
      {
        v27 = __fdelt_chk(v26);
        v25 = *(_DWORD *)(*(_QWORD *)v16 + 8LL);
        v103.fds_bits[v27] |= 1LL << v25;
      }
      if ( i < v25 )
        i = v25;
      ++v22;
    }
    if ( select(i + 1, &v103, &v104, 0LL, &v99) == -1 )
    {
      if ( dword_4CCE0 )
        break;
      v70 = __errno_location();
      sub_B0F0(3u, *v70, (__int64)"could not select from sockets");
      goto LABEL_171;
    }
    v28 = sub_B530(&tv.tv_sec, &v98);
    v29 = v28;
    if ( v28 >= 0 && dword_10290 > v28 )
    {
      sub_B0F0(7u, 0, (__int64)"updating the MIB (partial)");
      if ( (unsigned int)sub_71A0(0) == -1 )
        goto LABEL_171;
      v30 = (dword_10290 - v29) / 100;
      v31 = 10000 * ((dword_10290 - v29) % 100);
    }
    else
    {
      sub_B0F0(7u, 0, (__int64)"updating the MIB (full)");
      if ( (unsigned int)sub_71A0(1) == -1 )
        goto LABEL_171;
      tv = (timeval)_mm_load_si128((const __m128i *)&v98);
      v30 = dword_10290 / 100;
      v31 = 10000 * (dword_10290 % 100);
    }
    v99.tv_sec = v30;
    v99.tv_usec = v31;
    if ( (v103.fds_bits[__fdelt_chk(fd)] & (1LL << fd)) != 0 )
    {
      memset(v107, 0, sizeof(v107));
      *(_OWORD *)buf = 0LL;
      memset(cp, 0, 28);
      addr_len = 28;
      v59 = recvfrom(fd, &unk_4C43E, 0x800uLL, 0, cp, &addr_len);
      if ( v59 == -1 )
      {
        v65 = __errno_location();
        sub_B0F0(4u, *v65, (__int64)"Failed receiving UDP request on port %d", (unsigned __int16)word_1027A);
        goto LABEL_95;
      }
      qword_4C420 = time(0LL);
      v60 = _mm_loadu_si128((const __m128i *)&cp[0].sa_data[6]);
      ::n = v59;
      dword_4C428 = fd;
      dword_4CC48 = 0;
      xmmword_4C42C = (__int128)v60;
      word_4C43C = *(_WORD *)cp[0].sa_data;
      inet_ntop(10, &cp[0].sa_data[6], buf, 0x2Eu);
      if ( (unsigned int)sub_8A10((__int64)&qword_4C420) == -1 )
      {
        v67 = __errno_location();
        v68 = "Failed UDP request from";
        v69 = *(unsigned __int16 *)cp[0].sa_data;
        goto LABEL_153;
      }
      if ( !::n )
      {
        sub_B0F0(
          4u,
          0,
          (__int64)"%s %s:%d: ignored",
          "Failed UDP request from",
          buf,
          *(unsigned __int16 *)cp[0].sa_data);
        goto LABEL_95;
      }
      dword_4CC48 = 1;
      v61 = sendto(fd, &unk_4C43E, ::n, 64, cp, addr_len);
      inet_ntop(10, &cp[0].sa_data[6], buf, 0x2Eu);
      if ( v61 == -1 )
      {
        v67 = __errno_location();
        v68 = "Failed UDP response to";
        v69 = *(unsigned __int16 *)cp[0].sa_data;
LABEL_153:
        sub_B0F0(4u, *v67, (__int64)"%s %s:%d", v68, buf, v69);
        goto LABEL_95;
      }
      if ( ::n != v61 )
        sub_B0F0(
          4u,
          0,
          (__int64)"%s %s:%d: only %zd of %zu bytes sent",
          "Failed UDP response to",
          buf,
          *(unsigned __int16 *)cp[0].sa_data,
          v61,
          ::n);
    }
LABEL_95:
    if ( (v103.fds_bits[__fdelt_chk(dword_10270)] & (1LL << dword_10270)) == 0 )
      goto LABEL_96;
    memset(v107, 0, sizeof(v107));
    *(_OWORD *)buf = 0LL;
    memset(&addr[2], 0, 28);
    memset(cp, 0, 28);
    addr_len = 28;
    v51 = accept(dword_10270, cp, &addr_len);
    v52 = v51;
    if ( v51 == -1 )
    {
      v66 = __errno_location();
      sub_B0F0(3u, *v66, (__int64)"%s", "Could not accept TCP connection");
    }
    else
    {
      if ( v51 <= 1023 )
      {
        if ( (unsigned __int64)qword_4C380 <= 0xF )
        {
          v54 = (char *)sub_B440(0x830uLL);
          if ( !v54 )
            goto LABEL_171;
          v64 = qword_4C380++;
          qword_4C3A0[v64] = v54;
          goto LABEL_133;
        }
        v53 = sub_B000();
        v54 = (char *)v53;
        if ( v53 )
        {
          v55 = _mm_loadu_si128((const __m128i *)(v53 + 12));
          v56 = *(_WORD *)(v53 + 28);
          *(struct sockaddr *)&addr[2].sa_data[6] = (struct sockaddr)v55;
          *(_WORD *)addr[2].sa_data = v56;
          inet_ntop(10, &addr[2].sa_data[6], buf, 0x2Eu);
          sub_B0F0(
            4u,
            0,
            (__int64)"Maximum number of %d clients reached, kicking out %s:%d",
            16,
            buf,
            *(unsigned __int16 *)addr[2].sa_data);
          close(*((_DWORD *)v54 + 2));
LABEL_133:
          inet_ntop(10, &cp[0].sa_data[6], buf, 0x2Eu);
          sub_B0F0(7u, 0, (__int64)"Connected TCP client %s:%d", buf, *(unsigned __int16 *)cp[0].sa_data);
          v57 = time(0LL);
          *((_DWORD *)v54 + 2) = v52;
          v58 = _mm_loadu_si128((const __m128i *)&cp[0].sa_data[6]);
          *(_QWORD *)v54 = v57;
          LOWORD(v57) = *(_WORD *)cp[0].sa_data;
          *((_QWORD *)v54 + 260) = 0LL;
          *((_DWORD *)v54 + 522) = 0;
          *((_WORD *)v54 + 14) = v57;
          *(__m128i *)(v54 + 12) = v58;
          goto LABEL_96;
        }
        sub_B0F0(3u, 0, (__int64)"%s: internal error", "Could not accept TCP connection");
LABEL_169:
        exit(2);
      }
      sub_B0F0(3u, 0, (__int64)"%s: FD set overflow", "Could not accept TCP connection");
      close(v52);
    }
LABEL_96:
    v32 = 0LL;
    v33 = qword_4C3A0;
    if ( !qword_4C380 )
      continue;
    do
    {
      v37 = *(int *)(*v33 + 8);
      if ( *(_DWORD *)(*v33 + 2088) )
      {
        v34 = __fdelt_chk(v37);
        v35 = *v33;
        if ( (v104.fds_bits[v34] & (1LL << *(_DWORD *)(*v33 + 8))) == 0 )
          goto LABEL_99;
        memset(v107, 0, sizeof(v107));
        *(_OWORD *)buf = 0LL;
        v43 = *(_DWORD *)(v35 + 8);
        v44 = *(_WORD *)(v35 + 28);
        v45 = *(_QWORD *)(v35 + 2080);
        *(__m128i *)&cp[0].sa_data[6] = _mm_loadu_si128((const __m128i *)(v35 + 12));
        *(_WORD *)cp[0].sa_data = v44;
        sc = (char *)send(v43, (const void *)(v35 + 30), v45, 0);
        inet_ntop(10, &cp[0].sa_data[6], buf, 0x2Eu);
        if ( sc != (char *)-1LL )
        {
          if ( *(char **)(v35 + 2080) == sc )
          {
            *(_QWORD *)(v35 + 2080) = 0LL;
            *(_DWORD *)(v35 + 2088) = 0;
            goto LABEL_99;
          }
          sub_B0F0(
            4u,
            0,
            (__int64)"%s %s:%d: only %zd of %zu bytes written",
            "Failed TCP response to",
            buf,
            *(unsigned __int16 *)cp[0].sa_data,
            (size_t)sc,
            *(_QWORD *)(v35 + 2080));
          close(*(_DWORD *)(v35 + 8));
          goto LABEL_127;
        }
        v63 = __errno_location();
        sub_B0F0(4u, *v63, (__int64)"%s %s:%d", "Failed TCP response to", buf, *(unsigned __int16 *)cp[0].sa_data);
      }
      else
      {
        v38 = __fdelt_chk(v37);
        v35 = *v33;
        if ( (v103.fds_bits[v38] & (1LL << *(_DWORD *)(*v33 + 8))) == 0 )
          goto LABEL_99;
        memset(v107, 0, sizeof(v107));
        *(_OWORD *)buf = 0LL;
        v39 = *(_DWORD *)(v35 + 8);
        v40 = _mm_loadu_si128((const __m128i *)(v35 + 12));
        *(_WORD *)cp[0].sa_data = *(_WORD *)(v35 + 28);
        v41 = *(_QWORD *)(v35 + 2080);
        *(struct sockaddr *)&cp[0].sa_data[6] = (struct sockaddr)v40;
        sb = read(v39, (void *)(v35 + v41 + 30), 2048 - v41);
        inet_ntop(10, &cp[0].sa_data[6], buf, 0x2Eu);
        if ( sb == -1 )
          goto LABEL_140;
        if ( !sb )
        {
          sub_B0F0(7u, 0, (__int64)"TCP client %s:%d disconnected", buf, *(unsigned __int16 *)cp[0].sa_data);
          close(*(_DWORD *)(v35 + 8));
          *(_DWORD *)(v35 + 8) = -1;
          goto LABEL_99;
        }
        *(_QWORD *)v35 = time(0LL);
        *(_QWORD *)(v35 + 2080) += sb;
        v42 = sub_8930(v35);
        if ( v42 == -1 )
          goto LABEL_140;
        if ( !v42 )
          goto LABEL_99;
        *(_DWORD *)(v35 + 2088) = 0;
        if ( (unsigned int)sub_8A10(v35) == -1 )
        {
LABEL_140:
          v62 = __errno_location();
          sub_B0F0(4u, *v62, (__int64)"%s %s:%d", "Failed TCP request from", buf, *(unsigned __int16 *)cp[0].sa_data);
        }
        else
        {
          if ( *(_QWORD *)(v35 + 2080) )
          {
            *(_DWORD *)(v35 + 2088) = 1;
            goto LABEL_99;
          }
          sub_B0F0(
            4u,
            0,
            (__int64)"%s %s:%d: ignored",
            "Failed TCP request from",
            buf,
            *(unsigned __int16 *)cp[0].sa_data);
        }
      }
      close(*(_DWORD *)(v35 + 8));
LABEL_127:
      *(_DWORD *)(v35 + 8) = -1;
LABEL_99:
      v36 = qword_4C380;
      ++v32;
      ++v33;
    }
    while ( v32 < qword_4C380 );
    if ( qword_4C380 )
    {
      v46 = 0LL;
      do
      {
        v47 = (_DWORD *)qword_4C3A0[v46];
        if ( v47[2] == -1 )
        {
          qword_4C380 = --v36;
          if ( v46 < v36 )
          {
            free(v47);
            v48 = 8 * (v46 + 1);
            v49 = 128LL;
            if ( (unsigned __int64)(v48 - 8) >= 0x80 )
              v49 = v48 - 8;
            v50 = v36 - v46;
            v46 = 0LL;
            __memmove_chk(
              &qword_4C3A0[(unsigned __int64)v48 / 8 - 1],
              &qword_4C3A0[(unsigned __int64)v48 / 8],
              8 * v50,
              v49 - (v48 - 8));
            v36 = qword_4C380;
          }
          else
          {
            ++v46;
          }
        }
        else
        {
          v36 = qword_4C380;
          ++v46;
        }
      }
      while ( v46 < v36 );
    }
  }
  while ( !dword_4CCE0 );
LABEL_113:
  sub_B0F0(5u, 0, (__int64)"mini-snmpd v1.6 stopping");
  if ( !dword_4CCE4 )
    return 0LL;
  closelog();
  return 0LL;
}
// 2620: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);
// 2710: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 2780: using guessed type __int64 __fastcall __isoc23_strtol(_QWORD, _QWORD, _QWORD);
// 5C00: using guessed type __int64 sub_5C00(void);
// B000: using guessed type __int64 sub_B000(void);
// FB60: using guessed type __int128 in6addr_any;
// 101A0: using guessed type char *off_101A0;
// 101B0: using guessed type char *off_101B0;
// 10278: using guessed type __int16 word_10278;
// 1027A: using guessed type __int16 word_1027A;
// 10280: using guessed type __int64 qword_10280;
// 10288: using guessed type int dword_10288;
// 1028C: using guessed type int dword_1028C;
// 10290: using guessed type int dword_10290;
// 10294: using guessed type int dword_10294;
// 102A0: using guessed type char *off_102A0;
// 4C380: using guessed type __int64 qword_4C380;
// 4C3A0: using guessed type _QWORD qword_4C3A0[16];
// 4C420: using guessed type __int64 qword_4C420;
// 4C428: using guessed type int dword_4C428;
// 4C42C: using guessed type __int128 xmmword_4C42C;
// 4C43C: using guessed type __int16 word_4C43C;
// 4CC48: using guessed type int dword_4CC48;
// 4CC60: using guessed type _QWORD qword_4CC60[8];
// 4CCA8: using guessed type __int64 qword_4CCA8;
// 4CCB0: using guessed type __int64 qword_4CCB0;
// 4CCB8: using guessed type __int64 qword_4CCB8;
// 4CCC0: using guessed type __int64 qword_4CCC0;
// 4CCC8: using guessed type __int64 qword_4CCC8;
// 4CCE0: using guessed type int dword_4CCE0;
// 4CCE4: using guessed type int dword_4CCE4;
// 4CCE8: using guessed type int dword_4CCE8;

//----- (0000000000003E90) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 3E9A: positive sp value 8 has been found
// 3EA1: variable 'v3' is possibly undefined

//----- (0000000000003EC0) ----------------------------------------------------
void *sub_3EC0()
{
  return &unk_102C8;
}

//----- (0000000000003EF0) ----------------------------------------------------
__int64 sub_3EF0()
{
  return 0LL;
}
// 3EF0: using guessed type __int64 sub_3EF0();

//----- (0000000000003F30) ----------------------------------------------------
void *sub_3F30()
{
  void *result; // rax

  if ( !byte_10308 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(lpdso_handle);
    result = sub_3EC0();
    byte_10308 = 1;
  }
  return result;
}
// 10308: using guessed type char byte_10308;

//----- (0000000000003F70) ----------------------------------------------------
// attributes: thunk
__int64 sub_3F70()
{
  return sub_3EF0();
}
// 3EF0: using guessed type __int64 sub_3EF0(void);

//----- (0000000000003F80) ----------------------------------------------------
void sub_3F80()
{
  dword_4CCE0 = 1;
}
// 4CCE0: using guessed type int dword_4CCE0;

//----- (0000000000003F90) ----------------------------------------------------
__int64 __fastcall sub_3F90(unsigned int a1)
{
  __printf_chk(
    2LL,
    "Usage: %s [options]\n"
    "\n"
    "  -4, --use-ipv4         Use IPv4, default\n"
    "  -6, --use-ipv6         Use IPv6\n"
    "  -a, --auth             Enable authentication, i.e. SNMP version 2c\n"
    "  -c, --community STR    Community string, default: public\n"
    "  -C, --contact STR      System contact, default: none\n"
    "  -d, --disks PATH       Disks to monitor, default: /\n"
    "  -D, --description STR  System description, default: none\n"
    "  -h, --help             This help text\n"
    "  -i, --interfaces IFACE Network interfaces to monitor, default: none\n"
    "  -I, --listen IFACE     Network interface to listen, default: all\n"
    "  -l, --loglevel LEVEL   Set log level: none, err, info, notice*, debug\n"
    "  -L, --location STR     System location, default: none\n"
    "  -n, --foreground       Run in foreground, do not detach from controlling terminal\n"
    "  -p, --udp-port PORT    UDP port to bind to, default: 161\n"
    "  -P, --tcp-port PORT    TCP port to bind to, default: 161\n"
    "  -s, --syslog           Use syslog for logging, even if running in the foreground\n"
    "  -t, --timeout SEC      Timeout for MIB updates, default: 1 second\n"
    "  -u, --drop-privs USER  Drop privileges after opening sockets to USER, default: no\n"
    "  -v, --version          Show program version and exit\n"
    "  -V, --vendor OID       System vendor, default: none\n"
    "\n",
    ident);
  __printf_chk(2LL, "Bug report address: %s\n", "https://github.com/troglobit/mini-snmpd/issues");
  __printf_chk(2LL, "Project homepage: %s\n", "https://troglobit.com/projects/mini-snmpd/");
  return a1;
}
// 2840: using guessed type __int64 __printf_chk(_QWORD, const char *, ...);

//----- (0000000000003FF0) ----------------------------------------------------
__int64 sub_3FF0()
{
  int v0; // eax
  int v1; // edx
  __int64 result; // rax
  char v3[136]; // [rsp+0h] [rbp-98h] BYREF
  unsigned __int64 v4; // [rsp+88h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  v0 = sub_B480("/proc/uptime", v3, 128LL);
  v1 = -1;
  if ( v0 != -1 )
    v1 = (int)(strtod(v3, 0LL) * 100.0);
  result = (unsigned int)dword_1030C;
  if ( dword_1030C )
    return (unsigned int)(v1 - dword_1030C);
  dword_1030C = v1;
  return result;
}
// 3FF0: using guessed type __int64 sub_3FF0();
// 1030C: using guessed type int dword_1030C;

//----- (0000000000004090) ----------------------------------------------------
__int64 sub_4090()
{
  int v0; // edx
  __int64 result; // rax
  char v2[136]; // [rsp+0h] [rbp-98h] BYREF
  unsigned __int64 v3; // [rsp+88h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v0 = sub_B480("/proc/uptime", v2, 128LL);
  result = 0xFFFFFFFFLL;
  if ( v0 != -1 )
    return (unsigned int)(int)(strtod(v2, 0LL) * 100.0);
  return result;
}
// 4090: using guessed type __int64 sub_4090();

//----- (0000000000004110) ----------------------------------------------------
unsigned __int64 __fastcall sub_4110(_DWORD *a1)
{
  _DWORD *v1; // rbp
  _DWORD *v2; // r13
  char *v3; // rdi
  const unsigned __int16 **v4; // r12
  const unsigned __int16 *v5; // rsi
  char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  char *endptr; // [rsp+8h] [rbp-C0h] BYREF
  _BYTE v11[136]; // [rsp+10h] [rbp-B8h] BYREF
  unsigned __int64 v12; // [rsp+98h] [rbp-30h]

  v1 = a1;
  v12 = __readfsqword(0x28u);
  *(_QWORD *)a1 = 0LL;
  a1[2] = 0;
  if ( (unsigned int)sub_B480("/proc/loadavg", v11, 128LL) != -1 )
  {
    endptr = v11;
    v2 = a1 + 3;
    v3 = v11;
    v4 = __ctype_b_loc();
    while ( 1 )
    {
      v5 = *v4;
      v6 = v3 + 1;
      v7 = *v3;
      if ( ((*v4)[v7] & 0x2000) != 0 )
      {
        do
        {
          endptr = v6;
          v8 = *v6;
          v3 = v6++;
          LOBYTE(v7) = v8;
        }
        while ( (v5[v8] & 0x2000) != 0 );
      }
      if ( (_BYTE)v7 )
        *v1 = (int)(strtod(v3, &endptr) * 100.0);
      if ( v2 == ++v1 )
        break;
      v3 = endptr;
    }
  }
  return v12 - __readfsqword(0x28u);
}

//----- (0000000000004210) ----------------------------------------------------
unsigned __int64 __fastcall sub_4210(__int64 a1)
{
  _QWORD v2[131]; // [rsp+0h] [rbp-428h] BYREF
  unsigned __int64 v3; // [rsp+418h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0LL;
  *(_OWORD *)(a1 + 16) = 0LL;
  memset(v2, 0, 0x410uLL);
  v2[2] = a1;
  v2[0] = "MemTotal";
  v2[26] = "MemFree";
  v2[28] = a1 + 8;
  v2[52] = "MemShared";
  v2[54] = a1 + 16;
  v2[78] = "Buffers";
  v2[80] = a1 + 24;
  v2[104] = "Cached";
  v2[1] = 1LL;
  v2[27] = 1LL;
  v2[53] = 1LL;
  v2[79] = 1LL;
  v2[105] = 1LL;
  v2[106] = a1 + 32;
  sub_A870("/proc/meminfo", (__int64)v2, 5LL, 0LL);
  return v3 - __readfsqword(0x28u);
}

//----- (0000000000004340) ----------------------------------------------------
unsigned __int64 __fastcall sub_4340(_OWORD *a1)
{
  _QWORD v2[79]; // [rsp+0h] [rbp-288h] BYREF
  unsigned __int64 v3; // [rsp+278h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  memset(v2, 0, 0x270uLL);
  v2[2] = a1;
  v2[0] = "cpu ";
  v2[3] = (char *)a1 + 8;
  v2[4] = a1 + 1;
  v2[5] = (char *)a1 + 24;
  v2[26] = "intr ";
  v2[28] = a1 + 2;
  v2[52] = "ctxt ";
  v2[1] = 4LL;
  v2[27] = 1LL;
  v2[53] = 1LL;
  v2[54] = (char *)a1 + 40;
  sub_A870("/proc/stat", (__int64)v2, 3LL, 0LL);
  return v3 - __readfsqword(0x28u);
}

//----- (0000000000004440) ----------------------------------------------------
unsigned __int64 __fastcall sub_4440(__int64 a1)
{
  char v2; // [rsp+8h] [rbp-F0h] BYREF
  _QWORD v3[4]; // [rsp+10h] [rbp-E8h] BYREF
  __m128i v4; // [rsp+30h] [rbp-C8h]
  __m128i v5; // [rsp+40h] [rbp-B8h]
  __m128i v6; // [rsp+50h] [rbp-A8h]
  __m128i v7; // [rsp+60h] [rbp-98h]
  __m128i v8; // [rsp+70h] [rbp-88h]
  __int64 v9; // [rsp+80h] [rbp-78h]
  _BYTE v10[88]; // [rsp+88h] [rbp-70h] BYREF
  unsigned __int64 v11; // [rsp+E8h] [rbp-10h]

  v11 = __readfsqword(0x28u);
  *(_QWORD *)(a1 + 16) = 0LL;
  v3[2] = a1;
  memset(v10, 0, sizeof(v10));
  v3[0] = "Ip";
  v4 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)&v2, (__m128i)(unsigned __int64)&v2);
  v5 = v4;
  v6 = v4;
  v7 = v4;
  v8 = v4;
  v3[3] = a1 + 8;
  *(_OWORD *)a1 = 0LL;
  v3[1] = 13LL;
  v9 = a1 + 16;
  sub_A870("/proc/net/snmp", (__int64)v3, 1LL, 1LL);
  return v11 - __readfsqword(0x28u);
}

//----- (0000000000004520) ----------------------------------------------------
unsigned __int64 __fastcall sub_4520(_QWORD *a1)
{
  _QWORD v2[16]; // [rsp+0h] [rbp-F8h] BYREF
  __int128 v3; // [rsp+80h] [rbp-78h]
  __int128 v4; // [rsp+90h] [rbp-68h]
  __int128 v5; // [rsp+A0h] [rbp-58h]
  __int128 v6; // [rsp+B0h] [rbp-48h]
  __int128 v7; // [rsp+C0h] [rbp-38h]
  unsigned __int64 v8; // [rsp+D8h] [rbp-20h]

  v8 = __readfsqword(0x28u);
  v2[2] = a1;
  v2[0] = "Tcp";
  v2[4] = a1 + 2;
  v2[5] = a1 + 3;
  v2[6] = a1 + 4;
  v2[7] = a1 + 5;
  v2[8] = a1 + 6;
  v2[9] = a1 + 7;
  v2[10] = a1 + 8;
  v2[11] = a1 + 9;
  v2[12] = a1 + 10;
  v2[13] = a1 + 11;
  v2[14] = a1 + 12;
  v2[1] = 14LL;
  v2[3] = a1 + 1;
  v2[15] = a1 + 13;
  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  v7 = 0LL;
  if ( sub_A870("/proc/net/snmp", (__int64)v2, 1LL, 1LL) )
  {
    *a1 = 0LL;
    a1[13] = 0LL;
    memset(
      (void *)((unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 112) >> 3));
  }
  return v8 - __readfsqword(0x28u);
}

//----- (0000000000004670) ----------------------------------------------------
unsigned __int64 __fastcall sub_4670(_OWORD *a1)
{
  _QWORD v2[27]; // [rsp+0h] [rbp-E8h] BYREF
  unsigned __int64 v3; // [rsp+D8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v2[2] = a1;
  v2[1] = 4LL;
  memset(&v2[6], 0, 0xA0uLL);
  v2[0] = "Udp";
  v2[3] = (char *)a1 + 8;
  v2[4] = a1 + 1;
  v2[5] = (char *)a1 + 24;
  if ( sub_A870("/proc/net/snmp", (__int64)v2, 1LL, 1LL) )
  {
    *a1 = 0LL;
    a1[1] = 0LL;
  }
  return v3 - __readfsqword(0x28u);
}

//----- (0000000000004730) ----------------------------------------------------
unsigned __int64 __fastcall sub_4730(_OWORD *a1)
{
  bool v1; // zf
  unsigned __int64 v2; // rbx
  __fsblkcnt_t f_blocks; // rax
  float f_blocks_low; // xmm2_4
  float f_bsize_low; // xmm1_4
  __fsblkcnt_t f_bfree; // rdx
  float f_bfree_low; // xmm0_4
  __int64 v8; // rax
  float v9; // xmm0_4
  float f_files_low; // xmm1_4
  __fsfilcnt_t v12; // rax
  float v13; // xmm0_4
  struct statfs v14; // [rsp-8h] [rbp-A8h] BYREF
  unsigned __int64 v15; // [rsp+70h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  v1 = qword_10280 == 0;
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  if ( !v1 )
  {
    v2 = 0LL;
    do
    {
      if ( statfs((&off_102A0)[v2], &v14) != -1 )
      {
        f_blocks = v14.f_blocks;
        if ( (v14.f_blocks & 0x8000000000000000LL) != 0LL )
          f_blocks_low = (float)(int)(v14.f_blocks & 1 | (v14.f_blocks >> 1))
                       + (float)(int)(v14.f_blocks & 1 | (v14.f_blocks >> 1));
        else
          f_blocks_low = (float)SLODWORD(v14.f_blocks);
        f_bsize_low = (float)SLODWORD(v14.f_bsize);
        *((_DWORD *)a1 + v2) = (int)(float)((float)(f_blocks_low * (float)SLODWORD(v14.f_bsize)) * 0.0009765625);
        f_bfree = v14.f_bfree;
        if ( (v14.f_bfree & 0x8000000000000000LL) != 0LL )
          f_bfree_low = (float)(int)(v14.f_bfree & 1 | (v14.f_bfree >> 1))
                      + (float)(int)(v14.f_bfree & 1 | (v14.f_bfree >> 1));
        else
          f_bfree_low = (float)SLODWORD(v14.f_bfree);
        *((_DWORD *)a1 + v2 + 4) = (int)(float)((float)(f_bfree_low * f_bsize_low) * 0.0009765625);
        v8 = f_blocks - f_bfree;
        if ( v8 < 0 )
          v9 = (float)(v8 & 1 | (unsigned int)((unsigned __int64)v8 >> 1))
             + (float)(v8 & 1 | (unsigned int)((unsigned __int64)v8 >> 1));
        else
          v9 = (float)(int)v8;
        *((_DWORD *)a1 + v2 + 8) = (int)(float)((float)(f_bsize_low * v9) * 0.0009765625);
        *((_DWORD *)a1 + v2 + 12) = (int)(float)((float)((float)((float)(v9 * 100.0) + f_blocks_low) - 1.0)
                                               / f_blocks_low);
        if ( v14.f_files )
        {
          if ( (v14.f_files & 0x8000000000000000LL) != 0LL )
            f_files_low = (float)(int)(v14.f_files & 1 | (v14.f_files >> 1))
                        + (float)(int)(v14.f_files & 1 | (v14.f_files >> 1));
          else
            f_files_low = (float)SLODWORD(v14.f_files);
          v12 = v14.f_files - v14.f_ffree;
          if ( (__int64)(v14.f_files - v14.f_ffree) < 0 )
            v13 = (float)(int)(v12 & 1 | (v12 >> 1)) + (float)(int)(v12 & 1 | (v12 >> 1));
          else
            v13 = (float)(int)v12;
          *((_DWORD *)a1 + v2 + 16) = (int)(float)((float)((float)((float)(v13 * 100.0) + f_files_low) - 1.0)
                                                 / f_files_low);
        }
        else
        {
          *((_DWORD *)a1 + v2 + 16) = 0;
        }
      }
      ++v2;
    }
    while ( v2 < qword_10280 );
  }
  return v15 - __readfsqword(0x28u);
}
// 10280: using guessed type __int64 qword_10280;
// 102A0: using guessed type char *off_102A0;

//----- (00000000000049A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_49A0(__int64 a1)
{
  struct ifaddrs *v2; // rbx
  int v3; // eax
  struct sockaddr *ifa_addr; // rdx
  __int64 v5; // rbp
  _DWORD *v6; // r14
  unsigned int ifa_flags; // eax
  int v8; // esi
  int v9; // esi
  __int64 v10; // r15
  __int64 v11; // rsi
  sa_family_t sa_family; // dx
  __int64 v13; // rax
  __int64 v14; // rdx
  const char *v15; // rsi
  int v16; // edx
  int v17; // eax
  struct sockaddr *ifa_netmask; // rdi
  unsigned int v20; // ecx
  _DWORD *v21; // rsi
  struct sockaddr *ifu_broadaddr; // rax
  unsigned int v23; // eax
  struct ifaddrs *ifap; // [rsp+18h] [rbp-7A0h] BYREF
  _QWORD v25[235]; // [rsp+20h] [rbp-798h] BYREF
  unsigned __int64 v26; // [rsp+778h] [rbp-40h]

  v26 = __readfsqword(0x28u);
  if ( getifaddrs(&ifap) >= 0 )
  {
    memset(v25, 0, 0x750uLL);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 1160) = 0LL;
    memset(
      (void *)((a1 + 8) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 1168) >> 3));
    v2 = ifap;
    if ( ifap )
    {
      while ( 1 )
      {
        if ( v2->ifa_addr )
        {
          v3 = sub_B070(v2->ifa_name);
          if ( v3 != -1 )
          {
            ifa_addr = v2->ifa_addr;
            v5 = v3;
            if ( ifa_addr->sa_family != 2 )
              goto LABEL_6;
            ifa_netmask = v2->ifa_netmask;
            if ( ifa_netmask )
              break;
          }
        }
LABEL_17:
        v2 = v2->ifa_next;
        if ( !v2 )
          goto LABEL_18;
      }
      v5 = v3;
      v20 = *(_DWORD *)&ifa_addr->sa_data[2];
      v21 = (_DWORD *)(a1 + 4LL * v3);
      v21[8] = _byteswap_ulong(*(_DWORD *)&ifa_netmask->sa_data[2]);
      ifu_broadaddr = v2->ifa_ifu.ifu_broadaddr;
      *v21 = _byteswap_ulong(v20);
      if ( ifu_broadaddr && (v2->ifa_flags & 2) != 0 )
      {
        v23 = *(_DWORD *)&ifu_broadaddr->sa_data[2];
        v21[16] = _byteswap_ulong(v23);
        v21[24] = v23 != 0;
      }
LABEL_6:
      v6 = (_DWORD *)(a1 + 4 * v5);
      if ( !v6[80] )
      {
        ifa_flags = v2->ifa_flags;
        v8 = 23;
        if ( (ifa_flags & 0x10) == 0 )
          v8 = (v2->ifa_flags & 8) == 0 ? 6 : 24;
        v6[32] = v8;
        v9 = ifa_flags & 1;
        if ( (ifa_flags & 1) != 0 )
        {
          if ( (ifa_flags & 0x40) == 0 )
            v9 = 7;
        }
        else
        {
          v9 = 2;
        }
        v6[64] = v9;
        v10 = 4 * v5 + 160;
        v11 = a1 + 6 * v5 + 1120;
        *(_DWORD *)v11 = *(_DWORD *)&ifa_addr->sa_data[10];
        sa_family = ifa_addr[1].sa_family;
        v13 = 26 * v5;
        v25[v13 + 1] = 12LL;
        *(_WORD *)(v11 + 4) = sa_family;
        v14 = 8 * v5 + 352;
        v15 = (const char *)*((_QWORD *)&unk_4CC60 + v5);
        v25[v13 + 2] = a1 + v14;
        v25[v13 + 3] = a1 + v14 + 192;
        v25[v13 + 4] = a1 + v14 + 256;
        v25[v13 + 5] = a1 + v14 + 320;
        v25[v13 + 9] = a1 + v14 + 64;
        v25[v13 + 10] = a1 + v14 + 384;
        v25[v13 + 11] = a1 + v14 + 576;
        v25[v13] = v15;
        v25[v13 + 12] = a1 + v14 + 640;
        v25[v13 + 13] = a1 + v14 + 704;
        if ( (unsigned int)sub_AC30((_DWORD *)(a1 + v10), (__int64)"/sys/class/net/%s/mtu", v15) == -1 )
          v6[40] = 1500;
        v16 = sub_AC30((_DWORD *)(a1 + v10 + 32), (__int64)"/sys/class/net/%s/speed", *((const char **)&unk_4CC60 + v5));
        v17 = 1000000000;
        if ( v16 != -1 )
          v17 = 1000000 * v6[48];
        v6[48] = v17;
        v6[56] = if_nametoindex(v2->ifa_name);
        *(_DWORD *)(a1 + 292) = sub_3FF0();
        v6[80] = 1;
      }
      goto LABEL_17;
    }
LABEL_18:
    sub_A870("/proc/net/dev", (__int64)v25, 9LL, 0LL);
    freeifaddrs(ifap);
  }
  return v26 - __readfsqword(0x28u);
}
// 3FF0: using guessed type __int64 sub_3FF0(void);

//----- (0000000000004CC0) ----------------------------------------------------
__int64 __fastcall compar(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(a1[1] - a2[1]);
}

//----- (0000000000004CD0) ----------------------------------------------------
__int64 __fastcall sub_4CD0(__int64 a1)
{
  unsigned __int64 v1; // rdx
  unsigned int *v2; // rsi
  unsigned int *v3; // rax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  __int16 v6; // dx
  __int64 result; // rax
  __int16 v8; // cx
  bool v9; // cf
  char *v10; // rax

  v1 = *(_QWORD *)(a1 + 80);
  if ( v1 <= 2 )
  {
    v6 = 3;
    goto LABEL_11;
  }
  v2 = (unsigned int *)(a1 + 4 * v1);
  v3 = (unsigned int *)(a1 + 8);
  v4 = 1;
  do
  {
    while ( 1 )
    {
      v5 = *v3;
      if ( *v3 <= 0xFFFFFFF )
        break;
      v4 += 5;
LABEL_4:
      if ( ++v3 == v2 )
        goto LABEL_8;
    }
    if ( v5 <= 0x1FFFFF )
    {
      if ( v5 <= 0x3FFF )
        v4 += (v5 > 0x7F) + 1;
      else
        v4 += 3;
      goto LABEL_4;
    }
    ++v3;
    v4 += 4;
  }
  while ( v3 != v2 );
LABEL_8:
  if ( v4 > 0xFFFF )
  {
    v10 = sub_AD90(a1);
    sub_B0F0(3u, 0, (__int64)"Failed encoding '%s': OID overflow", v10);
    v6 = -1;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( v4 <= 0xFF )
    {
      v8 = v4 + 2;
      v9 = v4 < 0x80;
      v6 = v4 + 3;
      if ( v9 )
        v6 = v8;
    }
    else
    {
      v6 = v4 + 4;
    }
LABEL_11:
    result = 0LL;
  }
  *(_WORD *)(a1 + 88) = v6;
  return result;
}

//----- (0000000000004DB0) ----------------------------------------------------
__int64 __fastcall sub_4DB0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  size_t v4; // rsi
  _BYTE *v6; // rax
  char *v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  void *v10; // rax

  if ( !a2 )
    return 2LL;
  v4 = a3 + 4;
  if ( *(_QWORD *)(a1 + 8) < a3 + 4 )
  {
    *(_QWORD *)(a1 + 8) = v4;
    v10 = realloc(*(void **)a1, v4);
    *(_QWORD *)a1 = v10;
    if ( !v10 )
      return 2LL;
  }
  if ( a3 <= 0xFFFF )
  {
    v6 = *(_BYTE **)a1;
    **(_BYTE **)a1 = 4;
    if ( a3 > 0xFF )
    {
      v6[1] = -126;
      v7 = v6 + 4;
      *((_WORD *)v6 + 1) = __ROL2__(a3, 8);
    }
    else if ( a3 <= 0x7F )
    {
      v6[1] = a3;
      v7 = v6 + 2;
      if ( !a3 )
      {
LABEL_10:
        result = 0LL;
        *(_WORD *)(a1 + 16) = (_WORD)v7 - *(_WORD *)a1;
        return result;
      }
    }
    else
    {
      v6[1] = -127;
      v7 = v6 + 3;
      v6[2] = a3;
    }
    v8 = 0LL;
    do
    {
      v7[v8] = *(_BYTE *)(a2 + v8);
      ++v8;
    }
    while ( v8 != a3 );
    LOWORD(v7) = v8 + (_WORD)v7;
    goto LABEL_10;
  }
  sub_B0F0(3u, 0, (__int64)"Failed encoding: OCTET STRING overflow");
  return 0xFFFFFFFFLL;
}

//----- (0000000000004EA0) ----------------------------------------------------
__int64 __fastcall sub_4EA0(__int64 a1, int a2)
{
  _BYTE *v2; // rax

  if ( a2 == 6 )
  {
    *(_QWORD *)(a1 + 8) = 104LL;
    *(_WORD *)(a1 + 16) = 0;
    v2 = sub_B440(0x68uLL);
  }
  else if ( a2 > 6 )
  {
    if ( a2 > 67 )
    {
      if ( a2 != 70 )
        return 0xFFFFFFFFLL;
      *(_QWORD *)(a1 + 8) = 10LL;
      *(_WORD *)(a1 + 16) = 0;
      v2 = sub_B440(0xAuLL);
      goto LABEL_7;
    }
    if ( a2 <= 64 )
    {
      if ( a2 != 64 )
        return 0xFFFFFFFFLL;
LABEL_6:
      *(_QWORD *)(a1 + 8) = 6LL;
      *(_WORD *)(a1 + 16) = 0;
      v2 = sub_B440(6uLL);
      goto LABEL_7;
    }
    *(_QWORD *)(a1 + 8) = 7LL;
    *(_WORD *)(a1 + 16) = 0;
    v2 = sub_B440(7uLL);
  }
  else
  {
    switch ( a2 )
    {
      case 4:
        *(_QWORD *)(a1 + 8) = 4LL;
        *(_WORD *)(a1 + 16) = 0;
        v2 = sub_B440(4uLL);
        break;
      case 5:
        *(_QWORD *)(a1 + 8) = 3LL;
        *(_WORD *)(a1 + 16) = 0;
        v2 = sub_B440(3uLL);
        break;
      case 2:
        goto LABEL_6;
      default:
        return 0xFFFFFFFFLL;
    }
  }
LABEL_7:
  *(_QWORD *)a1 = v2;
  if ( v2 )
  {
    *v2 = a2;
    *(_BYTE *)(*(_QWORD *)a1 + 1LL) = 0;
    *(_BYTE *)(*(_QWORD *)a1 + 2LL) = 0;
    *(_WORD *)(a1 + 16) = 3;
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000004FE0) ----------------------------------------------------
__m128i *__fastcall sub_4FE0(const __m128i *a1, unsigned int a2, unsigned int a3, int a4)
{
  __int64 v4; // r12
  __int64 v5; // rdx
  __m128i si128; // xmm0
  __int64 v7; // rax
  __int64 v8; // r15
  __m128i *v9; // rbx
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  char *v14; // rax
  __int64 v15; // r9
  char *v16; // r8
  const char *v17; // rdx
  char *v18; // rax
  char *v19; // rax
  __int64 v20; // [rsp-10h] [rbp-58h]
  int v21; // [rsp+Ch] [rbp-3Ch]

  v4 = a3;
  v5 = qword_10360;
  if ( (unsigned __int64)qword_10360 > 0x7FF )
  {
    v14 = sub_AD90((__int64)a1);
    v15 = a2;
    v20 = v4;
    v16 = v14;
    v17 = "%s '%s.%d.%d': table overflow";
LABEL_7:
    v9 = 0LL;
    sub_B0F0(3u, 0, (__int64)v17, "Failed creating MIB entry", v16, v15, v20);
    return v9;
  }
  si128 = _mm_load_si128(a1);
  ++qword_10360;
  v7 = 15 * v5;
  v8 = 30 * v5;
  v9 = (__m128i *)&dword_10380[30 * v5];
  *v9 = si128;
  v9[1] = _mm_load_si128(a1 + 1);
  v9[2] = _mm_load_si128(a1 + 2);
  v9[3] = _mm_load_si128(a1 + 3);
  v9[4] = _mm_load_si128(a1 + 4);
  v9[5] = _mm_load_si128(a1 + 5);
  *v9 = _mm_load_si128(a1);
  v9[1] = _mm_load_si128(a1 + 1);
  v9[2] = _mm_load_si128(a1 + 2);
  v9[3] = _mm_load_si128(a1 + 3);
  v9[4] = _mm_load_si128(a1 + 4);
  v10 = a1[5].m128i_u64[0];
  v9[5] = _mm_load_si128(a1 + 5);
  if ( v10 > 0x13 || (v11 = 2 * v7, v9[5].m128i_i64[0] = v10 + 1, dword_10380[v11 + v10] = a2, v10 == 19) )
  {
    v18 = sub_AD90((__int64)a1);
    v15 = a2;
    v20 = v4;
    v16 = v18;
    v17 = "%s '%s.%d.%d': oid overflow";
    goto LABEL_7;
  }
  v9[5].m128i_i64[0] = v10 + 2;
  dword_10380[v10 + 1 + v11] = v4;
  v21 = sub_4CD0((__int64)v9);
  if ( v21 + (unsigned int)sub_4EA0((__int64)&dword_10380[v8 + 24], a4) )
  {
    v19 = sub_AD90((__int64)v9);
    v15 = a2;
    v20 = v4;
    v16 = v19;
    v17 = "%s '%s.%d.%d': unsupported type %d";
    goto LABEL_7;
  }
  return v9;
}
// 10360: using guessed type __int64 qword_10360;
// 10380: using guessed type _DWORD dword_10380[44836];

//----- (0000000000005190) ----------------------------------------------------
__int64 __fastcall sub_5190(__int64 a1, int a2, __int64 a3)
{
  int v4; // ebp
  _BYTE *v6; // rcx
  __int64 v7; // rsi
  char v8; // r8
  __int64 v9; // rax
  int v10; // ecx
  unsigned int v11; // edx
  _WORD *v13; // rcx
  _BYTE *v14; // rdx
  __int64 v15; // rdi
  char v16; // cl
  int v17; // esi
  unsigned __int64 v18; // rsi
  _BYTE *v19; // rax
  __int64 v20; // r8
  __int64 v21; // rcx
  char v22; // dl
  int v23; // edi
  size_t v24; // rax
  int *v25; // rax
  char *v26; // rdi
  __int64 v27; // r10
  unsigned __int64 v28; // rdx
  int *v29; // rsi
  unsigned int *v30; // rax
  unsigned __int64 v31; // rdx
  unsigned int v32; // ecx
  char v33; // al
  _BYTE *v34; // rcx
  unsigned int *v35; // rsi
  unsigned __int64 v36; // r8
  __int64 v37; // r9
  _BYTE *v38; // rdx
  int v39; // ecx
  unsigned int v40; // eax
  _BYTE *v41; // rdx
  __int64 v42; // rax
  int v43; // ecx
  unsigned int v44; // edx
  int v45; // ecx
  __int64 v46; // rax
  unsigned __int64 v47; // rdx
  int v48; // eax
  char *v49; // rax

  v4 = a2;
  memset(*(void **)a1, 0, *(_QWORD *)(a1 + 8));
  if ( a2 != 6 )
  {
    if ( a2 <= 6 )
    {
      if ( a2 != 4 )
      {
        if ( a2 != 5 )
        {
          if ( a2 == 2 )
          {
            v6 = *(_BYTE **)a1;
            v7 = *(_QWORD *)a1 + 2LL;
            if ( (unsigned int)(a3 + 0x800000) > 0xFFFFFF )
            {
              v8 = 4;
              v4 = 3;
            }
            else
            {
              v8 = 3;
              if ( (unsigned int)(a3 + 0x8000) <= 0xFFFF )
              {
                v8 = 2 - ((unsigned int)(a3 + 128) < 0x100);
                v4 = (unsigned int)(a3 + 128) >= 0x100;
              }
            }
            *v6 = 2;
            v9 = v7;
            v6[1] = v8;
            v10 = 8 * v4;
            do
            {
              ++v9;
              v11 = (unsigned int)a3 >> v10;
              v10 -= 8;
              *(_BYTE *)(v9 - 1) = v11;
            }
            while ( v10 != -8 );
            *(_WORD *)(a1 + 16) = v4 + 1 + v7 - *(_WORD *)a1;
            return 0LL;
          }
          return 1LL;
        }
        return 0LL;
      }
      if ( a3 )
      {
        v24 = strlen((const char *)a3);
        return sub_4DB0(a1, a3, v24);
      }
      return 2LL;
    }
    if ( a2 > 67 )
    {
      if ( a2 == 70 )
      {
        v18 = *(_QWORD *)a3;
        v19 = *(_BYTE **)a1;
        v20 = *(_QWORD *)a1 + 2LL;
        if ( *(_QWORD *)a3 >> 55 )
        {
          v22 = 8;
          v23 = 7;
        }
        else if ( (v18 & 0x7F800000000000LL) != 0 )
        {
          v22 = 7;
          v23 = 6;
        }
        else if ( (v18 & 0x7F8000000000LL) != 0 )
        {
          v22 = 6;
          v23 = 5;
        }
        else if ( (v18 & 0x7F80000000LL) != 0 )
        {
          v22 = 5;
          v23 = 4;
        }
        else if ( (v18 & 0x7F800000) != 0 )
        {
          v22 = 4;
          v23 = 3;
        }
        else if ( (v18 & 0x7F8000) != 0 )
        {
          v22 = 3;
          v23 = 2;
        }
        else
        {
          v21 = *(_QWORD *)a3 & 0x7F80LL;
          v22 = 2 - (v21 == 0);
          v23 = v21 != 0;
        }
        *v19 = 70;
        v45 = 8 * v23;
        v19[1] = v22;
        v46 = v20;
        do
        {
          ++v46;
          v47 = v18 >> v45;
          v45 -= 8;
          *(_BYTE *)(v46 - 1) = v47;
        }
        while ( v45 != -8 );
        *(_WORD *)(a1 + 16) = v23 + 1 + v20 - *(_WORD *)a1;
        return 0LL;
      }
      return 1LL;
    }
    if ( a2 <= 64 )
    {
      if ( a2 == 64 )
      {
        v13 = *(_WORD **)a1;
        *v13 = 1088;
        v13 += 3;
        *((_DWORD *)v13 - 1) = _byteswap_ulong(a3);
        *(_WORD *)(a1 + 16) = (_WORD)v13 - *(_WORD *)a1;
        return 0LL;
      }
      return 1LL;
    }
    v14 = *(_BYTE **)a1;
    v15 = *(_QWORD *)a1 + 2LL;
    if ( (unsigned int)a3 > 0x7FFFFF )
    {
      v16 = 4;
      v17 = 3;
    }
    else if ( (a3 & 0x7F8000) != 0 )
    {
      v16 = 3;
      v17 = 2;
    }
    else
    {
      v48 = a3 & 0x7F80;
      v16 = 2 - (v48 == 0);
      v17 = v48 != 0;
    }
    *v14 = v4;
    v42 = v15;
    v14[1] = v16;
    v43 = 8 * v17;
    do
    {
      ++v42;
      v44 = (unsigned int)a3 >> v43;
      v43 -= 8;
      *(_BYTE *)(v42 - 1) = v44;
    }
    while ( v43 != -8 );
    LOWORD(v15) = v17 + 1 + v15;
LABEL_60:
    *(_WORD *)(a1 + 16) = v15 - *(_WORD *)a1;
    return 0LL;
  }
  v25 = sub_AE10((char *)a3);
  v26 = *(char **)a1;
  v27 = (__int64)v25;
  if ( !v25 )
    return 2LL;
  v28 = *((_QWORD *)v25 + 10);
  if ( v28 <= 2 )
  {
    *v26 = 6;
    v33 = 1;
    goto LABEL_74;
  }
  v29 = &v25[v28];
  v30 = (unsigned int *)(v25 + 2);
  v31 = 1LL;
  do
  {
    v32 = *v30;
    if ( *v30 > 0xFFFFFFF )
    {
      v31 += 5LL;
    }
    else if ( v32 <= 0x1FFFFF )
    {
      if ( v32 <= 0x3FFF )
        v31 += (v32 > 0x7F) + 1LL;
      else
        v31 += 3LL;
    }
    else
    {
      v31 += 4LL;
    }
    ++v30;
  }
  while ( v30 != (unsigned int *)v29 );
  if ( v31 <= 0xFFFF )
  {
    *v26 = 6;
    v33 = v31;
    if ( v31 > 0xFF )
    {
      v26[1] = -126;
      v34 = v26 + 4;
      *((_WORD *)v26 + 1) = __ROL2__(v31, 8);
LABEL_45:
      v15 = (__int64)(v34 + 1);
      *v34 = *(_DWORD *)(v27 + 4) + 40 * *(_BYTE *)v27;
      if ( *(_QWORD *)(v27 + 80) <= 2uLL )
        goto LABEL_60;
      v35 = (unsigned int *)(v27 + 8);
      v36 = 2LL;
      while ( 1 )
      {
        v40 = *v35;
        if ( *v35 > 0xFFFFFFF )
        {
          v37 = 4LL;
          goto LABEL_51;
        }
        if ( v40 > 0x1FFFFF )
          break;
        if ( v40 > 0x3FFF )
        {
          v37 = 2LL;
LABEL_51:
          v38 = (_BYTE *)v15;
          v39 = 7 * v37;
          do
          {
            *v38++ = (v40 >> v39) | 0x80;
            v40 = *v35;
            v39 -= 7;
          }
          while ( v39 );
          goto LABEL_53;
        }
        v37 = 0LL;
        if ( v40 > 0x7F )
        {
          v37 = 1LL;
          goto LABEL_51;
        }
LABEL_53:
        v41 = (_BYTE *)(v15 + v37);
        v15 += v37 + 1;
        ++v36;
        *v41 = v40 & 0x7F;
        ++v35;
        if ( v36 >= *(_QWORD *)(v27 + 80) )
          goto LABEL_60;
      }
      v37 = 3LL;
      goto LABEL_51;
    }
    if ( v31 > 0x7F )
    {
      v26[1] = -127;
      v34 = v26 + 3;
      v26[2] = v31;
      goto LABEL_45;
    }
LABEL_74:
    v26[1] = v33;
    v34 = v26 + 2;
    goto LABEL_45;
  }
  v49 = sub_AD90(v27);
  sub_B0F0(3u, 0, (__int64)"Failed encoding '%s': OID overflow", v49);
  return 0xFFFFFFFFLL;
}

//----- (0000000000005690) ----------------------------------------------------
void __fastcall sub_5690(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbp
  __int64 v6; // rdx
  unsigned int v7; // eax
  __int64 v8; // rdx
  __int64 v9; // rax
  __m128i v10; // xmm4
  __m128i *v11; // r14
  int v12; // eax
  char *v13; // rax
  char *v14; // rax
  char *v15; // rax
  int v16; // r9d
  const char *v17; // rcx
  const char *v18; // r8
  char *v19; // rax
  int v20; // [rsp+4h] [rbp-54h]
  __int64 v21; // [rsp+8h] [rbp-50h]
  _DWORD *v22; // [rsp+8h] [rbp-50h]
  __int64 v23; // [rsp+10h] [rbp-48h]

  if ( nmemb )
  {
    v5 = 0LL;
    while ( 1 )
    {
      v6 = dword_10320[2 * v5];
      v7 = *(_DWORD *)(a3 + 4 * v6);
      if ( v7 )
      {
        *(__m128i *)(a1 + 40) = _mm_unpacklo_epi64(
                                  _mm_unpacklo_epi32(_mm_cvtsi32_si128(HIBYTE(v7)), _mm_cvtsi32_si128(BYTE2(v7))),
                                  _mm_unpacklo_epi32(
                                    _mm_cvtsi32_si128(BYTE1(v7)),
                                    _mm_cvtsi32_si128((unsigned __int8)v7)));
        v8 = *(unsigned int *)(a4 + 4 * v6);
        v9 = qword_10360;
        if ( (unsigned __int64)qword_10360 > 0x7FF )
        {
          v14 = sub_AD90(a1);
          sub_B0F0(3u, 0, (__int64)"%s '%s': table overflow", "Failed creating MIB entry", v14);
          return;
        }
        v10 = _mm_loadu_si128((const __m128i *)a1);
        v23 = v8;
        ++qword_10360;
        v11 = (__m128i *)&dword_10380[30 * v9];
        v21 = 30 * v9;
        *v11 = v10;
        v11[1] = _mm_loadu_si128((const __m128i *)(a1 + 16));
        v11[2] = _mm_loadu_si128((const __m128i *)(a1 + 32));
        v11[3] = _mm_loadu_si128((const __m128i *)(a1 + 48));
        v11[4] = _mm_loadu_si128((const __m128i *)(a1 + 64));
        v11[5] = _mm_loadu_si128((const __m128i *)(a1 + 80));
        v20 = sub_4CD0((__int64)v11);
        v22 = &dword_10380[v21 + 24];
        if ( v20 + (unsigned int)sub_4EA0((__int64)v22, a2) )
        {
          v15 = sub_AD90((__int64)v11);
          v16 = a2;
          v17 = "Failed creating MIB entry";
          v18 = v15;
LABEL_15:
          sub_B0F0(3u, 0, (__int64)"%s '%s': unsupported type %d", v17, v18, v16);
          return;
        }
        v12 = sub_5190((__int64)v22, a2, v23);
        if ( v12 )
          break;
      }
      if ( ++v5 >= nmemb )
        return;
    }
    if ( v12 == 1 )
    {
      v19 = sub_AD90((__int64)v11);
      v16 = a2;
      v17 = "Failed assigning value to OID";
      v18 = v19;
      goto LABEL_15;
    }
    if ( v12 == 2 )
    {
      v13 = sub_AD90((__int64)v11);
      sub_B0F0(3u, 0, (__int64)"%s '%s': invalid default value", "Failed assigning value to OID", v13);
    }
  }
}
// 10320: using guessed type int dword_10320[16];
// 10360: using guessed type __int64 qword_10360;
// 10380: using guessed type _DWORD dword_10380[44836];

//----- (00000000000058B0) ----------------------------------------------------
_QWORD *__fastcall sub_58B0(const __m128i *a1, unsigned int a2, unsigned int a3, unsigned __int64 *a4)
{
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r12
  bool v8; // cf
  _QWORD *v9; // rbx
  _QWORD *v10; // r14
  char *v11; // rax
  const char *v12; // rdx
  char *v13; // r8
  __int64 v14; // r9
  char *v16; // rax
  __int64 v17; // [rsp-10h] [rbp-D8h]
  _OWORD v19[5]; // [rsp+20h] [rbp-A8h] BYREF
  __m128i si128; // [rsp+70h] [rbp-58h]
  unsigned __int64 v21; // [rsp+88h] [rbp-40h]

  v5 = a1[5].m128i_u64[0];
  v21 = __readfsqword(0x28u);
  v19[0] = _mm_load_si128(a1);
  v19[1] = _mm_load_si128(a1 + 1);
  v19[2] = _mm_load_si128(a1 + 2);
  v19[3] = _mm_load_si128(a1 + 3);
  v19[4] = _mm_load_si128(a1 + 4);
  si128 = _mm_load_si128(a1 + 5);
  if ( v5 > 0x13 || (*((_DWORD *)v19 + v5) = a2, v5 == 19) )
  {
    v16 = sub_AD90((__int64)a1);
    v12 = "%s '%s.%d.%d': OID overflow";
    v13 = v16;
    v17 = a3;
    v14 = a2;
    goto LABEL_9;
  }
  v6 = *a4;
  v7 = v5 + 2;
  v8 = *a4 < qword_10360;
  *((_DWORD *)v19 + v5 + 1) = a3;
  si128.m128i_i64[0] = v5 + 2;
  if ( !v8 )
  {
LABEL_8:
    v11 = sub_AD90((__int64)a1);
    v12 = "%s '%s.%d.%d': OID not found";
    v13 = v11;
    v17 = a3;
    v14 = a2;
LABEL_9:
    v10 = 0LL;
    sub_B0F0(3u, 0, (__int64)v12, "Failed updating OID", v13, v14, v17);
    return v10;
  }
  v9 = &dword_10380[30 * v6];
  while ( 1 )
  {
    v10 = v9;
    if ( v9[10] >= v7 && !memcmp(v9, v19, 4 * v7) )
      return v10;
    ++v6;
    v9 += 15;
    *a4 = v6;
    if ( v6 >= qword_10360 )
      goto LABEL_8;
  }
}
// 10360: using guessed type __int64 qword_10360;
// 10380: using guessed type _DWORD dword_10380[44836];

//----- (0000000000005A50) ----------------------------------------------------
__int64 __fastcall sub_5A50(
        const __m128i *a1,
        unsigned int a2,
        unsigned int a3,
        unsigned __int64 *a4,
        int a5,
        __int64 a6)
{
  __int64 v8; // rbp
  _QWORD *v9; // rax
  __int64 result; // rax
  char *v11; // rax
  char *v12; // rax

  v8 = a3;
  v9 = sub_58B0(a1, a2, a3, a4);
  if ( v9 )
  {
    result = sub_5190((__int64)(v9 + 12), a5, a6);
    switch ( (_DWORD)result )
    {
      case 0:
        return result;
      case 1:
        v12 = sub_AD90((__int64)a1);
        sub_B0F0(3u, 0, (__int64)"%s '%s.%d.%d': unsupported type %d", "Failed assigning value to OID", v12, a2, v8);
        break;
      case 2:
        v11 = sub_AD90((__int64)a1);
        sub_B0F0(3u, 0, (__int64)"%s '%s.%d.%d': invalid default value", "Failed assigning value to OID", v11, a2, v8);
        break;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000005B00) ----------------------------------------------------
__int64 __fastcall sub_5B00(const __m128i *a1, unsigned int a2, unsigned int a3, int a4, __int64 a5)
{
  __int64 v6; // r13
  __m128i *v8; // rax
  __int64 v9; // rbx
  __int64 result; // rax
  char *v11; // rax
  char *v12; // rax

  v6 = a3;
  v8 = sub_4FE0(a1, a2, a3, a4);
  if ( v8 )
  {
    v9 = (__int64)v8;
    result = sub_5190((__int64)v8[6].m128i_i64, a4, a5);
    switch ( (_DWORD)result )
    {
      case 0:
        return result;
      case 1:
        v12 = sub_AD90(v9);
        sub_B0F0(3u, 0, (__int64)"%s '%s.%d.%d': unsupported type %d", "Failed assigning value to OID", v12, a2, v6);
        break;
      case 2:
        v11 = sub_AD90(v9);
        sub_B0F0(3u, 0, (__int64)"%s '%s.%d.%d': invalid default value", "Failed assigning value to OID", v11, a2, v6);
        break;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000005C00) ----------------------------------------------------
__int64 sub_5C00()
{
  size_t v0; // rsi
  __int64 v1; // rax
  int v2; // edx
  __int64 v3; // rbp
  __int64 v5; // rbx
  int v6; // eax
  __int64 v7; // rbx
  unsigned __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  unsigned int v11; // ebx
  signed int v12; // r13d
  unsigned int v13; // ebp
  size_t v14; // rax
  unsigned int v15; // ebp
  signed int v16; // r13d
  signed int v17; // r13d
  unsigned int v18; // ebp
  signed int v19; // r13d
  unsigned int v20; // ebp
  signed int v21; // r13d
  unsigned int v22; // ebp
  signed int v23; // r13d
  unsigned int v24; // ebp
  __int64 v25; // rbx
  signed int v26; // r13d
  unsigned int v27; // ebp
  __int64 v28; // rbp
  signed int v29; // r13d
  unsigned int v30; // ebp
  signed int v31; // r13d
  unsigned int v32; // ebp
  signed int v33; // r13d
  unsigned int v34; // ebp
  signed int v35; // r13d
  unsigned int v36; // ebp
  signed int v37; // r13d
  unsigned int v38; // ebp
  __int64 v39; // rbx
  __int64 v40; // rbp
  __int64 v41; // rbx
  __int64 v42; // rbx
  __int64 v43; // rbp
  int v44; // r12d
  unsigned int v45; // ebx
  __int64 v46; // rbx
  unsigned int v47; // ebx
  __int64 v48; // rbx
  __int64 v49; // rbp
  signed int v50; // r12d
  unsigned int v51; // ebx
  signed int v52; // r12d
  unsigned int v53; // ebx
  signed int v54; // r12d
  unsigned int v55; // ebx
  signed int v56; // r12d
  unsigned int v57; // ebx
  signed int v58; // r12d
  unsigned int v59; // ebx
  __int64 v60; // rbx
  __int64 v61; // rbp
  __int64 v62; // rbx
  __int64 v63; // rbp
  __int64 v64; // rbx
  signed int v65; // r12d
  unsigned int v66; // ebx
  signed int v67; // r12d
  unsigned int v68; // ebx
  signed int v69; // r12d
  unsigned int v70; // ebx
  signed int v71; // r12d
  unsigned int v72; // ebx
  signed int v73; // r12d
  unsigned int v74; // ebx
  signed int v75; // r12d
  unsigned int v76; // ebx
  signed int v77; // r12d
  unsigned int v78; // ebx
  __m128i si128; // [rsp+0h] [rbp-698h] BYREF
  __m128i v80; // [rsp+10h] [rbp-688h]
  __int64 v81; // [rsp+20h] [rbp-678h]
  __int128 v82; // [rsp+28h] [rbp-670h]
  __int128 v83; // [rsp+38h] [rbp-660h]
  __int64 v84; // [rsp+48h] [rbp-650h]
  __int64 v85; // [rsp+50h] [rbp-648h]
  __int64 v86; // [rsp+58h] [rbp-640h]
  _OWORD v87[2]; // [rsp+60h] [rbp-638h] BYREF
  __int64 v88; // [rsp+80h] [rbp-618h]
  __int128 v89; // [rsp+88h] [rbp-610h]
  __int128 v90; // [rsp+98h] [rbp-600h]
  __int64 v91; // [rsp+A8h] [rbp-5F0h]
  __int64 v92; // [rsp+B0h] [rbp-5E8h]
  __int64 v93; // [rsp+B8h] [rbp-5E0h]
  _OWORD v94[2]; // [rsp+C0h] [rbp-5D8h] BYREF
  __int64 v95; // [rsp+E0h] [rbp-5B8h]
  __int128 v96; // [rsp+E8h] [rbp-5B0h]
  __int128 v97; // [rsp+F8h] [rbp-5A0h]
  __int64 v98; // [rsp+108h] [rbp-590h]
  __int64 v99; // [rsp+110h] [rbp-588h]
  __int64 v100; // [rsp+118h] [rbp-580h]
  _OWORD v101[2]; // [rsp+120h] [rbp-578h] BYREF
  __int64 v102; // [rsp+140h] [rbp-558h]
  __int128 v103; // [rsp+148h] [rbp-550h]
  __int128 v104; // [rsp+158h] [rbp-540h]
  __int64 v105; // [rsp+168h] [rbp-530h]
  __int64 v106; // [rsp+170h] [rbp-528h]
  __int64 v107; // [rsp+178h] [rbp-520h]
  _DWORD v108[8]; // [rsp+180h] [rbp-518h] BYREF
  _BYTE v109[64]; // [rsp+1A0h] [rbp-4F8h] BYREF
  _BYTE v110[128]; // [rsp+1E0h] [rbp-4B8h] BYREF
  _DWORD v111[236]; // [rsp+260h] [rbp-438h] BYREF
  char v112[16]; // [rsp+610h] [rbp-88h] BYREF
  char name[72]; // [rsp+620h] [rbp-78h] BYREF
  unsigned __int64 v114; // [rsp+668h] [rbp-30h]

  v114 = __readfsqword(0x28u);
  if ( gethostname(name, 0x40uLL) == -1 )
    name[0] = 0;
  else
    name[63] = 0;
  sub_49A0((__int64)v108);
  if ( (unsigned int)sub_5B00(xmmword_D980, 1u, 0, 4, qword_4CCC0) == -1
    || (unsigned int)sub_5B00(xmmword_D980, 2u, 0, 6, qword_4CCC8) == -1
    || !sub_4FE0(xmmword_D980, 3u, 0, 67)
    || (unsigned int)sub_5B00(xmmword_D980, 4u, 0, 4, qword_4CCB0) == -1
    || (unsigned int)sub_5B00(xmmword_D980, 5u, 0, 4, (__int64)name) == -1
    || (unsigned int)sub_5B00(xmmword_D980, 6u, 0, 4, qword_4CCB8) == -1
    || (unsigned int)sub_5B00(xmmword_D980, 7u, 0, 2, 79LL) == -1 )
  {
    return 0xFFFFFFFFLL;
  }
  if ( !nmemb )
    goto LABEL_11;
  if ( (unsigned int)sub_5B00(xmmword_D920, 1u, 0, 2, (unsigned int)nmemb) == -1 )
    return 0xFFFFFFFFLL;
  v5 = 0LL;
  if ( nmemb )
  {
    while ( (unsigned int)sub_5B00(xmmword_D8C0, 1u, (int)v5 + 1, 2, (unsigned int)v111[v5]) != -1 )
    {
      v6 = nmemb;
      if ( ++v5 >= nmemb )
      {
        if ( !nmemb )
          goto LABEL_171;
        v7 = 0LL;
        while ( (unsigned int)sub_5B00(xmmword_D8C0, 2u, (int)v7 + 1, 4, qword_4CC60[v7]) != -1 )
        {
          v6 = nmemb;
          if ( ++v7 >= nmemb )
          {
            if ( !nmemb )
              goto LABEL_171;
            v25 = 0LL;
            while ( (unsigned int)sub_5B00(xmmword_D8C0, 3u, (int)v25 + 1, 2, 6LL) != -1 )
            {
              v6 = nmemb;
              if ( ++v25 >= nmemb )
              {
                if ( !nmemb )
                  goto LABEL_171;
                v39 = 0LL;
                while ( (unsigned int)sub_5B00(xmmword_D8C0, 4u, (int)v39 + 1, 2, 1500LL) != -1 )
                {
                  v6 = nmemb;
                  if ( ++v39 >= nmemb )
                  {
                    if ( !nmemb )
                      goto LABEL_171;
                    v42 = 0LL;
                    while ( (unsigned int)sub_5B00(xmmword_D8C0, 5u, (int)v42 + 1, 66, 1000000000LL) != -1 )
                    {
                      v6 = nmemb;
                      if ( ++v42 >= nmemb )
                      {
                        if ( !nmemb )
                          goto LABEL_171;
                        v48 = 1LL;
                        while ( (unsigned int)sub_5B00(xmmword_D8C0, 6u, v48, 4, (__int64)"") != -1 )
                        {
                          v6 = nmemb;
                          if ( nmemb < ++v48 )
                          {
                            if ( !nmemb )
                              goto LABEL_171;
                            v60 = 0LL;
                            while ( (unsigned int)sub_5B00(xmmword_D8C0, 7u, (int)v60 + 1, 2, 1LL) != -1 )
                            {
                              v6 = nmemb;
                              if ( ++v60 >= nmemb )
                              {
                                if ( !nmemb )
                                  goto LABEL_171;
                                v62 = 0LL;
                                while ( (unsigned int)sub_5B00(xmmword_D8C0, 8u, (int)v62 + 1, 2, 1LL) != -1 )
                                {
                                  if ( ++v62 >= nmemb )
                                  {
                                    if ( !nmemb )
                                      goto LABEL_11;
                                    v64 = 0LL;
                                    while ( (unsigned int)sub_5B00(xmmword_D8C0, 9u, (int)v64 + 1, 67, 0LL) != -1 )
                                    {
                                      if ( ++v64 >= nmemb )
                                      {
                                        v67 = nmemb;
                                        if ( (int)nmemb <= 0 )
                                          goto LABEL_11;
                                        v68 = 1;
                                        while ( sub_4FE0(xmmword_D8C0, 0xAu, v68, 65) )
                                        {
                                          if ( v67 < (int)++v68 )
                                            goto LABEL_170;
                                        }
                                        return 0xFFFFFFFFLL;
                                      }
                                    }
                                    return 0xFFFFFFFFLL;
                                  }
                                }
                                return 0xFFFFFFFFLL;
                              }
                            }
                            return 0xFFFFFFFFLL;
                          }
                        }
                        return 0xFFFFFFFFLL;
                      }
                    }
                    return 0xFFFFFFFFLL;
                  }
                }
                return 0xFFFFFFFFLL;
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
LABEL_170:
    v6 = nmemb;
LABEL_171:
    v44 = v6;
    v45 = 1;
    if ( v6 <= 0 )
    {
LABEL_11:
      if ( sub_4FE0(xmmword_D860, 1u, 0, 2) && sub_4FE0(xmmword_D860, 2u, 0, 2) && sub_4FE0(xmmword_D860, 0xDu, 0, 2) )
      {
        v81 = 0x100000001LL;
        v86 = 15LL;
        v88 = 0x200000001LL;
        v95 = 0x300000001LL;
        v100 = 15LL;
        v84 = 0LL;
        v91 = 0LL;
        v98 = 0LL;
        v85 = 14LL;
        v92 = 14LL;
        v93 = 15LL;
        v99 = 14LL;
        v82 = 0LL;
        v83 = 0LL;
        si128 = _mm_load_si128((const __m128i *)&xmmword_D9E0);
        v80 = _mm_load_si128((const __m128i *)&xmmword_D9F0);
        v89 = 0LL;
        v90 = 0LL;
        v87[0] = si128;
        v87[1] = v80;
        v96 = 0LL;
        v97 = 0LL;
        v94[0] = si128;
        v94[1] = v80;
        v103 = 0LL;
        v107 = 15LL;
        v0 = nmemb;
        v102 = 0x400000001LL;
        v1 = 0LL;
        v105 = 0LL;
        v104 = 0LL;
        v106 = 14LL;
        v101[0] = si128;
        v101[1] = v80;
        if ( nmemb )
        {
          do
          {
            v2 = v108[v1];
            dword_10320[2 * v1] = v1;
            dword_10320[2 * v1++ + 1] = v2;
          }
          while ( v0 != v1 );
        }
        qsort(dword_10320, v0, 8uLL, (__compar_fn_t)compar);
        sub_5690((__int64)&si128, 64, (__int64)v108, (__int64)v108);
        sub_5690((__int64)v87, 2, (__int64)v108, (__int64)v111);
        sub_5690((__int64)v94, 64, (__int64)v108, (__int64)v109);
        sub_5690((__int64)v101, 2, (__int64)v108, (__int64)v110);
        if ( sub_4FE0(xmmword_D800, 1u, 0, 2) )
        {
          if ( sub_4FE0(xmmword_D800, 2u, 0, 2)
            && sub_4FE0(xmmword_D800, 3u, 0, 2)
            && sub_4FE0(xmmword_D800, 4u, 0, 2)
            && sub_4FE0(xmmword_D800, 5u, 0, 65)
            && sub_4FE0(xmmword_D800, 6u, 0, 65)
            && sub_4FE0(xmmword_D800, 7u, 0, 65)
            && sub_4FE0(xmmword_D800, 8u, 0, 65)
            && sub_4FE0(xmmword_D800, 9u, 0, 66)
            && sub_4FE0(xmmword_D800, 0xAu, 0, 65)
            && sub_4FE0(xmmword_D800, 0xBu, 0, 65)
            && sub_4FE0(xmmword_D800, 0xCu, 0, 65)
            && sub_4FE0(xmmword_D800, 0xEu, 0, 65)
            && sub_4FE0(xmmword_D800, 0xFu, 0, 65)
            && sub_4FE0(xmmword_D7A0, 1u, 0, 65)
            && sub_4FE0(xmmword_D7A0, 2u, 0, 65)
            && sub_4FE0(xmmword_D7A0, 3u, 0, 65)
            && sub_4FE0(xmmword_D7A0, 4u, 0, 65)
            && sub_4FE0(xmmword_D7A0, 8u, 0, 70)
            && sub_4FE0(xmmword_D7A0, 9u, 0, 70)
            && sub_4FE0(xmmword_D740, 1u, 0, 67) )
          {
            if ( nmemb )
            {
              v3 = 0LL;
              while ( (unsigned int)sub_5B00(xmmword_D6E0, 1u, (int)v3 + 1, 4, qword_4CC60[v3]) != -1 )
              {
                if ( ++v3 >= nmemb )
                {
                  v12 = nmemb;
                  if ( !(_DWORD)nmemb )
                    goto LABEL_54;
                  v13 = 1;
                  while ( sub_4FE0(xmmword_D6E0, 2u, v13, 65) )
                  {
                    if ( v12 < (int)++v13 )
                    {
                      v14 = nmemb;
                      v15 = 1;
                      v16 = nmemb;
                      if ( (int)nmemb > 0 )
                      {
                        while ( sub_4FE0(xmmword_D6E0, 3u, v15, 65) )
                        {
                          if ( v16 < (int)++v15 )
                          {
                            v14 = nmemb;
                            v17 = nmemb;
                            if ( (int)nmemb <= 0 )
                              goto LABEL_115;
                            v18 = 1;
                            while ( sub_4FE0(xmmword_D6E0, 4u, v18, 65) )
                            {
                              if ( v17 < (int)++v18 )
                              {
                                v14 = nmemb;
                                v19 = nmemb;
                                if ( (int)nmemb <= 0 )
                                  goto LABEL_115;
                                v20 = 1;
                                while ( sub_4FE0(xmmword_D6E0, 5u, v20, 65) )
                                {
                                  if ( v19 < (int)++v20 )
                                  {
                                    v14 = nmemb;
                                    v21 = nmemb;
                                    if ( (int)nmemb <= 0 )
                                      goto LABEL_115;
                                    v22 = 1;
                                    while ( sub_4FE0(xmmword_D6E0, 6u, v22, 70) )
                                    {
                                      if ( v21 < (int)++v22 )
                                      {
                                        v14 = nmemb;
                                        v23 = nmemb;
                                        if ( (int)nmemb <= 0 )
                                          goto LABEL_115;
                                        v24 = 1;
                                        while ( sub_4FE0(xmmword_D6E0, 7u, v24, 70) )
                                        {
                                          if ( v23 < (int)++v24 )
                                          {
                                            v14 = nmemb;
                                            v26 = nmemb;
                                            if ( (int)nmemb <= 0 )
                                              goto LABEL_115;
                                            v27 = 1;
                                            while ( sub_4FE0(xmmword_D6E0, 8u, v27, 70) )
                                            {
                                              if ( v26 < (int)++v27 )
                                              {
                                                v14 = nmemb;
                                                v29 = nmemb;
                                                if ( (int)nmemb <= 0 )
                                                  goto LABEL_115;
                                                v30 = 1;
                                                while ( sub_4FE0(xmmword_D6E0, 9u, v30, 70) )
                                                {
                                                  if ( v29 < (int)++v30 )
                                                  {
                                                    v14 = nmemb;
                                                    v31 = nmemb;
                                                    if ( (int)nmemb <= 0 )
                                                      goto LABEL_115;
                                                    v32 = 1;
                                                    while ( sub_4FE0(xmmword_D6E0, 0xAu, v32, 70) )
                                                    {
                                                      if ( v31 < (int)++v32 )
                                                      {
                                                        v14 = nmemb;
                                                        v33 = nmemb;
                                                        if ( (int)nmemb <= 0 )
                                                          goto LABEL_115;
                                                        v34 = 1;
                                                        while ( sub_4FE0(xmmword_D6E0, 0xBu, v34, 70) )
                                                        {
                                                          if ( v33 < (int)++v34 )
                                                          {
                                                            v14 = nmemb;
                                                            v35 = nmemb;
                                                            if ( (int)nmemb <= 0 )
                                                              goto LABEL_115;
                                                            v36 = 1;
                                                            while ( sub_4FE0(xmmword_D6E0, 0xCu, v36, 70) )
                                                            {
                                                              if ( v35 < (int)++v36 )
                                                              {
                                                                v14 = nmemb;
                                                                v37 = nmemb;
                                                                if ( (int)nmemb <= 0 )
                                                                  goto LABEL_115;
                                                                v38 = 1;
                                                                while ( sub_4FE0(xmmword_D6E0, 0xDu, v38, 70) )
                                                                {
                                                                  if ( v37 < (int)++v38 )
                                                                  {
                                                                    v14 = nmemb;
                                                                    goto LABEL_115;
                                                                  }
                                                                }
                                                                return 0xFFFFFFFFLL;
                                                              }
                                                            }
                                                            return 0xFFFFFFFFLL;
                                                          }
                                                        }
                                                        return 0xFFFFFFFFLL;
                                                      }
                                                    }
                                                    return 0xFFFFFFFFLL;
                                                  }
                                                }
                                                return 0xFFFFFFFFLL;
                                              }
                                            }
                                            return 0xFFFFFFFFLL;
                                          }
                                        }
                                        return 0xFFFFFFFFLL;
                                      }
                                    }
                                    return 0xFFFFFFFFLL;
                                  }
                                }
                                return 0xFFFFFFFFLL;
                              }
                            }
                            return 0xFFFFFFFFLL;
                          }
                        }
                      }
                      else
                      {
LABEL_115:
                        if ( !v14 )
                          goto LABEL_54;
                        v28 = 0LL;
                        while ( (unsigned int)sub_5B00(xmmword_D6E0, 0xEu, (int)v28 + 1, 2, 2LL) != -1 )
                        {
                          if ( ++v28 >= nmemb )
                          {
                            if ( !nmemb )
                              goto LABEL_54;
                            v40 = 0LL;
                            while ( (unsigned int)sub_5B00(xmmword_D6E0, 0xFu, (int)v40 + 1, 66, 0LL) != -1 )
                            {
                              if ( ++v40 >= nmemb )
                              {
                                if ( !nmemb )
                                  goto LABEL_54;
                                v43 = 0LL;
                                while ( (unsigned int)sub_5B00(xmmword_D6E0, 0x10u, (int)v43 + 1, 2, 2LL) != -1 )
                                {
                                  if ( ++v43 >= nmemb )
                                  {
                                    if ( !nmemb )
                                      goto LABEL_54;
                                    v49 = 0LL;
                                    while ( (unsigned int)sub_5B00(xmmword_D6E0, 0x11u, (int)v49 + 1, 2, 1LL) != -1 )
                                    {
                                      if ( ++v49 >= nmemb )
                                      {
                                        if ( !nmemb )
                                          goto LABEL_54;
                                        v61 = 0LL;
                                        while ( (unsigned int)sub_5B00(
                                                                xmmword_D6E0,
                                                                0x12u,
                                                                (int)v61 + 1,
                                                                4,
                                                                qword_4CC60[v61]) != -1 )
                                        {
                                          if ( ++v61 >= nmemb )
                                          {
                                            if ( !nmemb )
                                              goto LABEL_54;
                                            v63 = 0LL;
                                            while ( (unsigned int)sub_5B00(xmmword_D6E0, 0x13u, (int)v63 + 1, 67, 0LL) != -1 )
                                            {
                                              if ( ++v63 >= nmemb )
                                                goto LABEL_54;
                                            }
                                            return 0xFFFFFFFFLL;
                                          }
                                        }
                                        return 0xFFFFFFFFLL;
                                      }
                                    }
                                    return 0xFFFFFFFFLL;
                                  }
                                }
                                return 0xFFFFFFFFLL;
                              }
                            }
                            return 0xFFFFFFFFLL;
                          }
                        }
                      }
                      return 0xFFFFFFFFLL;
                    }
                  }
                  return 0xFFFFFFFFLL;
                }
              }
            }
            else
            {
LABEL_54:
              if ( sub_4FE0(xmmword_D680, 5u, 0, 2)
                && sub_4FE0(xmmword_D680, 6u, 0, 2)
                && sub_4FE0(xmmword_D680, 0xDu, 0, 2)
                && sub_4FE0(xmmword_D680, 0xEu, 0, 2)
                && sub_4FE0(xmmword_D680, 0xFu, 0, 2) )
              {
                v8 = 1LL;
                if ( qword_10280 )
                {
                  while ( (unsigned int)sub_5B00(xmmword_D620, 1u, v8, 2, (unsigned int)v8) != -1 )
                  {
                    if ( v8 >= qword_10280 )
                    {
                      if ( !qword_10280 )
                        goto LABEL_60;
                      v41 = 0LL;
                      while ( (unsigned int)sub_5B00(xmmword_D620, 2u, (int)v41 + 1, 4, (__int64)(&off_102A0)[v41]) != -1 )
                      {
                        if ( ++v41 >= (unsigned __int64)qword_10280 )
                        {
                          v50 = qword_10280;
                          if ( !(_DWORD)qword_10280 )
                            goto LABEL_60;
                          v51 = 1;
                          while ( sub_4FE0(xmmword_D620, 6u, v51, 2) )
                          {
                            if ( v50 < (int)++v51 )
                            {
                              v52 = qword_10280;
                              if ( (int)qword_10280 <= 0 )
                                goto LABEL_60;
                              v53 = 1;
                              while ( sub_4FE0(xmmword_D620, 7u, v53, 2) )
                              {
                                if ( v52 < (int)++v53 )
                                {
                                  v54 = qword_10280;
                                  if ( (int)qword_10280 <= 0 )
                                    goto LABEL_60;
                                  v55 = 1;
                                  while ( sub_4FE0(xmmword_D620, 8u, v55, 2) )
                                  {
                                    if ( v54 < (int)++v55 )
                                    {
                                      v56 = qword_10280;
                                      if ( (int)qword_10280 <= 0 )
                                        goto LABEL_60;
                                      v57 = 1;
                                      while ( sub_4FE0(xmmword_D620, 9u, v57, 2) )
                                      {
                                        if ( v56 < (int)++v57 )
                                        {
                                          v58 = qword_10280;
                                          if ( (int)qword_10280 <= 0 )
                                            goto LABEL_60;
                                          v59 = 1;
                                          while ( sub_4FE0(xmmword_D620, 0xAu, v59, 2) )
                                          {
                                            if ( v58 < (int)++v59 )
                                              goto LABEL_60;
                                          }
                                          return 0xFFFFFFFFLL;
                                        }
                                      }
                                      return 0xFFFFFFFFLL;
                                    }
                                  }
                                  return 0xFFFFFFFFLL;
                                }
                              }
                              return 0xFFFFFFFFLL;
                            }
                          }
                          return 0xFFFFFFFFLL;
                        }
                      }
                      return 0xFFFFFFFFLL;
                    }
                    ++v8;
                  }
                }
                else
                {
LABEL_60:
                  v9 = 1LL;
                  while ( (unsigned int)sub_5B00(xmmword_D5C0, 1u, v9, 2, v9) != -1 )
                  {
                    if ( ++v9 == 4 )
                    {
                      v10 = 1LL;
                      while ( 1 )
                      {
                        __snprintf_chk(v112, 16LL, 2LL, 16LL, "Load-%d", dword_D53C[v10]);
                        if ( (unsigned int)sub_5B00(xmmword_D5C0, 2u, v10, 4, (__int64)v112) == -1 )
                          break;
                        if ( ++v10 == 4 )
                        {
                          v11 = 1;
                          while ( sub_4FE0(xmmword_D5C0, 3u, v11, 4) )
                          {
                            if ( ++v11 == 4 )
                            {
                              v46 = 1LL;
                              while ( 1 )
                              {
                                __snprintf_chk(v112, 16LL, 2LL, 16LL, "%d", dword_D53C[v46]);
                                if ( (unsigned int)sub_5B00(xmmword_D5C0, 4u, v46, 4, (__int64)v112) == -1 )
                                  break;
                                if ( ++v46 == 4 )
                                {
                                  v47 = 1;
                                  while ( sub_4FE0(xmmword_D5C0, 5u, v47, 2) )
                                  {
                                    if ( ++v47 == 4 )
                                    {
                                      if ( sub_4FE0(xmmword_D560, 0x32u, 0, 65)
                                        && sub_4FE0(xmmword_D560, 0x33u, 0, 65)
                                        && sub_4FE0(xmmword_D560, 0x34u, 0, 65)
                                        && sub_4FE0(xmmword_D560, 0x35u, 0, 65)
                                        && sub_4FE0(xmmword_D560, 0x3Bu, 0, 65) )
                                      {
                                        return (unsigned int)-(sub_4FE0(xmmword_D560, 0x3Cu, 0, 65) == 0LL);
                                      }
                                      return 0xFFFFFFFFLL;
                                    }
                                  }
                                  return 0xFFFFFFFFLL;
                                }
                              }
                              return 0xFFFFFFFFLL;
                            }
                          }
                          return 0xFFFFFFFFLL;
                        }
                      }
                      return 0xFFFFFFFFLL;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    while ( sub_4FE0(xmmword_D8C0, 0xBu, v45, 65) )
    {
      if ( v44 < (int)++v45 )
      {
        v65 = nmemb;
        if ( (int)nmemb <= 0 )
          goto LABEL_11;
        v66 = 1;
        while ( sub_4FE0(xmmword_D8C0, 0xDu, v66, 65) )
        {
          if ( v65 < (int)++v66 )
          {
            v69 = nmemb;
            if ( (int)nmemb <= 0 )
              goto LABEL_11;
            v70 = 1;
            while ( sub_4FE0(xmmword_D8C0, 0xEu, v70, 65) )
            {
              if ( v69 < (int)++v70 )
              {
                v71 = nmemb;
                if ( (int)nmemb <= 0 )
                  goto LABEL_11;
                v72 = 1;
                while ( sub_4FE0(xmmword_D8C0, 0x10u, v72, 65) )
                {
                  if ( v71 < (int)++v72 )
                  {
                    v73 = nmemb;
                    if ( (int)nmemb <= 0 )
                      goto LABEL_11;
                    v74 = 1;
                    while ( sub_4FE0(xmmword_D8C0, 0x11u, v74, 65) )
                    {
                      if ( v73 < (int)++v74 )
                      {
                        v75 = nmemb;
                        if ( (int)nmemb <= 0 )
                          goto LABEL_11;
                        v76 = 1;
                        while ( sub_4FE0(xmmword_D8C0, 0x13u, v76, 65) )
                        {
                          if ( v75 < (int)++v76 )
                          {
                            v77 = nmemb;
                            if ( (int)nmemb <= 0 )
                              goto LABEL_11;
                            v78 = 1;
                            while ( sub_4FE0(xmmword_D8C0, 0x14u, v78, 65) )
                            {
                              if ( v77 < (int)++v78 )
                                goto LABEL_11;
                            }
                            return 0xFFFFFFFFLL;
                          }
                        }
                        return 0xFFFFFFFFLL;
                      }
                    }
                    return 0xFFFFFFFFLL;
                  }
                }
                return 0xFFFFFFFFLL;
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}
// 2500: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 5C00: using guessed type __int64 sub_5C00();
// D53C: using guessed type _DWORD dword_D53C[9];
// D560: using guessed type __m128i xmmword_D560[6];
// D5C0: using guessed type __m128i xmmword_D5C0[6];
// D620: using guessed type __m128i xmmword_D620[6];
// D680: using guessed type __m128i xmmword_D680[6];
// D6E0: using guessed type __m128i xmmword_D6E0[6];
// D740: using guessed type __m128i xmmword_D740[6];
// D7A0: using guessed type __m128i xmmword_D7A0[6];
// D800: using guessed type __m128i xmmword_D800[6];
// D860: using guessed type __m128i xmmword_D860[6];
// D8C0: using guessed type __m128i xmmword_D8C0[6];
// D920: using guessed type __m128i xmmword_D920[6];
// D980: using guessed type __m128i xmmword_D980[6];
// D9E0: using guessed type __int128 xmmword_D9E0;
// D9F0: using guessed type __int128 xmmword_D9F0;
// 10280: using guessed type __int64 qword_10280;
// 102A0: using guessed type char *off_102A0;
// 10320: using guessed type int dword_10320[16];
// 4CC60: using guessed type _QWORD qword_4CC60[8];
// 4CCB0: using guessed type __int64 qword_4CCB0;
// 4CCB8: using guessed type __int64 qword_4CCB8;
// 4CCC0: using guessed type __int64 qword_4CCC0;
// 4CCC8: using guessed type __int64 qword_4CCC8;

//----- (00000000000071A0) ----------------------------------------------------
__int64 __fastcall sub_71A0(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  __int64 v3; // r15
  unsigned int v5; // eax
  __int64 v6; // r12
  __int64 v7; // r12
  __int64 v8; // r15
  size_t m; // r14
  __int64 v10; // rbp
  __int64 v11; // r15
  __int64 v12; // rbp
  __int64 v13; // r12
  __int64 v14; // r14
  char *v15; // r14
  size_t v16; // r12
  _QWORD *v17; // rax
  int v18; // eax
  __int64 v19; // r12
  __int64 v20; // r14
  __int64 v21; // rbp
  __int64 v22; // r14
  __int64 v23; // rbp
  __int64 v24; // r12
  __int64 v25; // r14
  __int64 v26; // rbp
  __int64 v27; // r12
  __int64 v28; // r14
  __int64 v29; // rbp
  char *v30; // rax
  __int64 v31; // r14
  __int64 v32; // r14
  __int64 v33; // r14
  __int64 v34; // r14
  __int64 v35; // r14
  __int64 v36; // r14
  __int64 v37; // r14
  __int64 v38; // r14
  __int64 v39; // r14
  __int64 v40; // r14
  size_t i; // r12
  size_t j; // r12
  size_t k; // r12
  unsigned __int64 v44; // [rsp+10h] [rbp-568h] BYREF
  unsigned __int64 v45; // [rsp+18h] [rbp-560h] BYREF
  __int128 v46; // [rsp+20h] [rbp-558h] BYREF
  unsigned int v47; // [rsp+30h] [rbp-548h]
  unsigned __int64 v48; // [rsp+38h] [rbp-540h]
  _DWORD v49[2]; // [rsp+40h] [rbp-538h]
  unsigned int v50; // [rsp+48h] [rbp-530h]
  _DWORD v51[4]; // [rsp+50h] [rbp-528h]
  _DWORD v52[12]; // [rsp+60h] [rbp-518h]
  _DWORD v53[280]; // [rsp+90h] [rbp-4E8h] BYREF
  char v54; // [rsp+4F0h] [rbp-88h] BYREF
  _BYTE v55[24]; // [rsp+520h] [rbp-58h] BYREF
  unsigned __int64 v56; // [rsp+538h] [rbp-40h]

  v56 = __readfsqword(0x28u);
  v44 = 0LL;
  v1 = sub_3FF0();
  if ( (unsigned int)sub_5A50(xmmword_D980, 3u, 0, &v44, 67, v1) == -1 )
    return 0xFFFFFFFFLL;
  if ( a1 )
  {
    if ( nmemb )
    {
      sub_49A0((__int64)v53);
      if ( nmemb )
      {
        v6 = 0LL;
        while ( (unsigned int)sub_5A50(xmmword_D8C0, 3u, (int)v6 + 1, &v44, 2, (unsigned int)v53[v6 + 32]) != -1 )
        {
          if ( ++v6 >= nmemb )
          {
            if ( !nmemb )
              goto LABEL_199;
            v7 = 0LL;
            while ( (unsigned int)sub_5A50(xmmword_D8C0, 4u, (int)v7 + 1, &v44, 2, (unsigned int)v53[v7 + 40]) != -1 )
            {
              if ( ++v7 >= nmemb )
              {
                if ( !nmemb )
                  goto LABEL_199;
                v13 = 0LL;
                while ( (unsigned int)sub_5A50(xmmword_D8C0, 5u, (int)v13 + 1, &v44, 66, (unsigned int)v53[v13 + 48]) != -1 )
                {
                  if ( ++v13 >= nmemb )
                  {
                    if ( !nmemb )
                      goto LABEL_199;
                    v15 = &v54;
                    v16 = 0LL;
                    while ( 1 )
                    {
                      v17 = sub_58B0(xmmword_D8C0, 6u, (int)v16 + 1, &v44);
                      if ( !v17 )
                        return 0xFFFFFFFFLL;
                      v18 = sub_4DB0((__int64)(v17 + 12), (__int64)v15, 6uLL);
                      if ( v18 )
                      {
                        if ( v18 == 2 )
                        {
                          v30 = sub_AD90((__int64)xmmword_D8C0);
                          sub_B0F0(
                            3u,
                            0,
                            (__int64)"%s '%s.%d.%d': invalid default value",
                            "Failed assigning value to OID",
                            v30,
                            6,
                            v16 + 1);
                        }
                        return 0xFFFFFFFFLL;
                      }
                      ++v16;
                      v15 += 6;
                      if ( v16 >= nmemb )
                      {
                        if ( !nmemb )
                          goto LABEL_199;
                        v19 = 0LL;
                        while ( (unsigned int)sub_5A50(
                                                xmmword_D8C0,
                                                7u,
                                                (int)v19 + 1,
                                                &v44,
                                                2,
                                                (v53[v19 + 64] == 2) + 1LL) != -1 )
                        {
                          if ( ++v19 >= nmemb )
                          {
                            if ( !nmemb )
                              goto LABEL_199;
                            v24 = 0LL;
                            while ( (unsigned int)sub_5A50(
                                                    xmmword_D8C0,
                                                    8u,
                                                    (int)v24 + 1,
                                                    &v44,
                                                    2,
                                                    (unsigned int)v53[v24 + 64]) != -1 )
                            {
                              if ( ++v24 >= nmemb )
                              {
                                if ( !nmemb )
                                  goto LABEL_199;
                                v27 = 0LL;
                                while ( (unsigned int)sub_5A50(
                                                        xmmword_D8C0,
                                                        9u,
                                                        (int)v27 + 1,
                                                        &v44,
                                                        67,
                                                        (unsigned int)v53[v27 + 72]) != -1 )
                                {
                                  if ( ++v27 >= nmemb )
                                  {
                                    if ( !nmemb )
                                      goto LABEL_199;
                                    v31 = 0LL;
                                    while ( (unsigned int)sub_5A50(xmmword_D8C0, 0xAu, (int)v31 + 1, &v44, 65, 0LL) != -1 )
                                    {
                                      if ( ++v31 >= nmemb )
                                      {
                                        if ( !nmemb )
                                          goto LABEL_199;
                                        v33 = 0LL;
                                        while ( (unsigned int)sub_5A50(xmmword_D8C0, 0xBu, (int)v33 + 1, &v44, 65, 0LL) != -1 )
                                        {
                                          if ( ++v33 >= nmemb )
                                          {
                                            if ( !nmemb )
                                              goto LABEL_199;
                                            v35 = 0LL;
                                            while ( (unsigned int)sub_5A50(
                                                                    xmmword_D8C0,
                                                                    0xDu,
                                                                    (int)v35 + 1,
                                                                    &v44,
                                                                    65,
                                                                    0LL) != -1 )
                                            {
                                              if ( ++v35 >= nmemb )
                                              {
                                                if ( !nmemb )
                                                  goto LABEL_199;
                                                v37 = 0LL;
                                                while ( (unsigned int)sub_5A50(
                                                                        xmmword_D8C0,
                                                                        0xEu,
                                                                        (int)v37 + 1,
                                                                        &v44,
                                                                        65,
                                                                        0LL) != -1 )
                                                {
                                                  if ( ++v37 >= nmemb )
                                                  {
                                                    if ( !nmemb )
                                                      goto LABEL_203;
                                                    v39 = 0LL;
                                                    while ( (unsigned int)sub_5A50(
                                                                            xmmword_D8C0,
                                                                            0x10u,
                                                                            (int)v39 + 1,
                                                                            &v44,
                                                                            65,
                                                                            0LL) != -1 )
                                                    {
                                                      if ( ++v39 >= nmemb )
                                                        goto LABEL_199;
                                                    }
                                                    return 0xFFFFFFFFLL;
                                                  }
                                                }
                                                return 0xFFFFFFFFLL;
                                              }
                                            }
                                            return 0xFFFFFFFFLL;
                                          }
                                        }
                                        return 0xFFFFFFFFLL;
                                      }
                                    }
                                    return 0xFFFFFFFFLL;
                                  }
                                }
                                return 0xFFFFFFFFLL;
                              }
                            }
                            return 0xFFFFFFFFLL;
                          }
                        }
                        return 0xFFFFFFFFLL;
                      }
                    }
                  }
                }
                return 0xFFFFFFFFLL;
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
        return 0xFFFFFFFFLL;
      }
LABEL_199:
      for ( i = 0LL; i < nmemb; ++i )
      {
        if ( (unsigned int)sub_5A50(
                             xmmword_D8C0,
                             0x11u,
                             (int)i + 1,
                             &v44,
                             65,
                             (unsigned int)(*(_QWORD *)&v53[2 * i + 232] % 0xFFFFFFFFLL)) == -1 )
          return 0xFFFFFFFFLL;
      }
LABEL_203:
      for ( j = 0LL; j < nmemb; ++j )
      {
        if ( (unsigned int)sub_5A50(
                             xmmword_D8C0,
                             0x13u,
                             (int)j + 1,
                             &v44,
                             65,
                             (unsigned int)(*(_QWORD *)&v53[2 * j + 264] % 0xFFFFFFFFLL)) == -1 )
          return 0xFFFFFFFFLL;
      }
      for ( k = 0LL; k < nmemb; ++k )
      {
        if ( (unsigned int)sub_5A50(
                             xmmword_D8C0,
                             0x14u,
                             (int)k + 1,
                             &v44,
                             65,
                             (unsigned int)(*(_QWORD *)&v53[2 * k + 248] % 0xFFFFFFFFLL)) == -1 )
          return 0xFFFFFFFFLL;
      }
    }
    sub_4440((__int64)&v46);
    if ( (unsigned int)sub_5A50(xmmword_D860, 1u, 0, &v44, 2, (unsigned int)v46) != -1
      && (unsigned int)sub_5A50(xmmword_D860, 2u, 0, &v44, 2, DWORD2(v46)) != -1
      && (unsigned int)sub_5A50(xmmword_D860, 0xDu, 0, &v44, 2, v47) != -1 )
    {
      sub_4520(&v46);
      if ( (unsigned int)sub_5A50(xmmword_D800, 1u, 0, &v44, 2, (unsigned int)v46) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 2u, 0, &v44, 2, DWORD2(v46)) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 3u, 0, &v44, 2, v47) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 4u, 0, &v44, 2, (unsigned int)v48) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 5u, 0, &v44, 65, v49[0]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 6u, 0, &v44, 65, v50) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 7u, 0, &v44, 65, v51[0]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 8u, 0, &v44, 65, v51[2]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 9u, 0, &v44, 66, v52[0]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 0xAu, 0, &v44, 65, v52[2]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 0xBu, 0, &v44, 65, v52[4]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 0xCu, 0, &v44, 65, v52[6]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 0xEu, 0, &v44, 65, v52[8]) != -1
        && (unsigned int)sub_5A50(xmmword_D800, 0xFu, 0, &v44, 65, v52[10]) != -1 )
      {
        sub_4670(&v46);
        if ( (unsigned int)sub_5A50(xmmword_D7A0, 1u, 0, &v44, 65, (unsigned int)v46) != -1
          && (unsigned int)sub_5A50(xmmword_D7A0, 2u, 0, &v44, 65, DWORD2(v46)) != -1
          && (unsigned int)sub_5A50(xmmword_D7A0, 3u, 0, &v44, 65, v47) != -1
          && (unsigned int)sub_5A50(xmmword_D7A0, 4u, 0, &v44, 65, (unsigned int)v48) != -1 )
        {
          v45 = v46;
          if ( (unsigned int)sub_5A50(xmmword_D7A0, 8u, 0, &v44, 70, (__int64)&v45) != -1 )
          {
            v45 = v48;
            if ( (unsigned int)sub_5A50(xmmword_D7A0, 9u, 0, &v44, 70, (__int64)&v45) != -1 )
            {
              v2 = sub_4090();
              if ( (unsigned int)sub_5A50(xmmword_D740, 1u, 0, &v44, 67, v2) != -1 )
              {
                v3 = 0LL;
                if ( nmemb )
                {
                  while ( (unsigned int)sub_5A50(xmmword_D6E0, 2u, (int)v3 + 1, &v44, 65, 0LL) != -1 )
                  {
                    if ( ++v3 >= nmemb )
                    {
                      if ( !nmemb )
                      {
LABEL_50:
                        for ( m = 0LL; m < nmemb; ++m )
                        {
                          if ( (unsigned int)sub_5A50(xmmword_D6E0, 0xFu, (int)m + 1, &v44, 66, v53[m + 48] / 0xF4240u) == -1 )
                            return 0xFFFFFFFFLL;
                        }
                        goto LABEL_54;
                      }
                      v8 = 0LL;
                      while ( (unsigned int)sub_5A50(xmmword_D6E0, 3u, (int)v8 + 1, &v44, 65, 0LL) != -1 )
                      {
                        if ( ++v8 >= nmemb )
                        {
                          if ( !nmemb )
                            goto LABEL_50;
                          v14 = 0LL;
                          while ( (unsigned int)sub_5A50(xmmword_D6E0, 4u, (int)v14 + 1, &v44, 65, 0LL) != -1 )
                          {
                            if ( ++v14 >= nmemb )
                            {
                              if ( !nmemb )
                                goto LABEL_50;
                              v20 = 0LL;
                              while ( (unsigned int)sub_5A50(xmmword_D6E0, 5u, (int)v20 + 1, &v44, 65, 0LL) != -1 )
                              {
                                if ( ++v20 >= nmemb )
                                {
                                  if ( !nmemb )
                                    goto LABEL_50;
                                  v22 = 0LL;
                                  while ( 1 )
                                  {
                                    v45 = *(_QWORD *)&v53[2 * v22 + 88] & 0xBFFFFFFFFFFFFFFFLL;
                                    if ( (unsigned int)sub_5A50(xmmword_D6E0, 6u, (int)v22 + 1, &v44, 70, (__int64)&v45) == -1 )
                                      return 0xFFFFFFFFLL;
                                    if ( ++v22 >= nmemb )
                                    {
                                      if ( !nmemb )
                                        goto LABEL_50;
                                      v25 = 0LL;
                                      while ( 1 )
                                      {
                                        v45 = *(_QWORD *)&v53[2 * v25 + 136] & 0xBFFFFFFFFFFFFFFFLL;
                                        if ( (unsigned int)sub_5A50(
                                                             xmmword_D6E0,
                                                             7u,
                                                             (int)v25 + 1,
                                                             &v44,
                                                             70,
                                                             (__int64)&v45) == -1 )
                                          return 0xFFFFFFFFLL;
                                        if ( ++v25 >= nmemb )
                                        {
                                          if ( !nmemb )
                                            goto LABEL_50;
                                          v28 = 0LL;
                                          while ( 1 )
                                          {
                                            v45 = *(_QWORD *)&v53[2 * v28 + 104] & 0xBFFFFFFFFFFFFFFFLL;
                                            if ( (unsigned int)sub_5A50(
                                                                 xmmword_D6E0,
                                                                 8u,
                                                                 (int)v28 + 1,
                                                                 &v44,
                                                                 70,
                                                                 (__int64)&v45) == -1 )
                                              return 0xFFFFFFFFLL;
                                            if ( ++v28 >= nmemb )
                                            {
                                              if ( !nmemb )
                                                goto LABEL_50;
                                              v32 = 0LL;
                                              while ( 1 )
                                              {
                                                v45 = *(_QWORD *)&v53[2 * v32 + 120] & 0xBFFFFFFFFFFFFFFFLL;
                                                if ( (unsigned int)sub_5A50(
                                                                     xmmword_D6E0,
                                                                     9u,
                                                                     (int)v32 + 1,
                                                                     &v44,
                                                                     70,
                                                                     (__int64)&v45) == -1 )
                                                  return 0xFFFFFFFFLL;
                                                if ( ++v32 >= nmemb )
                                                {
                                                  if ( !nmemb )
                                                    goto LABEL_50;
                                                  v34 = 0LL;
                                                  while ( 1 )
                                                  {
                                                    v45 = *(_QWORD *)&v53[2 * v34 + 184] & 0xBFFFFFFFFFFFFFFFLL;
                                                    if ( (unsigned int)sub_5A50(
                                                                         xmmword_D6E0,
                                                                         0xAu,
                                                                         (int)v34 + 1,
                                                                         &v44,
                                                                         70,
                                                                         (__int64)&v45) == -1 )
                                                      return 0xFFFFFFFFLL;
                                                    if ( ++v34 >= nmemb )
                                                    {
                                                      if ( !nmemb )
                                                        goto LABEL_50;
                                                      v36 = 0LL;
                                                      while ( 1 )
                                                      {
                                                        v45 = *(_QWORD *)&v53[2 * v36 + 232] & 0xBFFFFFFFFFFFFFFFLL;
                                                        if ( (unsigned int)sub_5A50(
                                                                             xmmword_D6E0,
                                                                             0xBu,
                                                                             (int)v36 + 1,
                                                                             &v44,
                                                                             70,
                                                                             (__int64)&v45) == -1 )
                                                          return 0xFFFFFFFFLL;
                                                        if ( ++v36 >= nmemb )
                                                        {
                                                          if ( !nmemb )
                                                            goto LABEL_50;
                                                          v38 = 0LL;
                                                          while ( 1 )
                                                          {
                                                            v45 = *(_QWORD *)&v53[2 * v38 + 200] & 0xBFFFFFFFFFFFFFFFLL;
                                                            if ( (unsigned int)sub_5A50(
                                                                                 xmmword_D6E0,
                                                                                 0xCu,
                                                                                 (int)v38 + 1,
                                                                                 &v44,
                                                                                 70,
                                                                                 (__int64)&v45) == -1 )
                                                              return 0xFFFFFFFFLL;
                                                            if ( ++v38 >= nmemb )
                                                            {
                                                              if ( !nmemb )
                                                                goto LABEL_54;
                                                              v40 = 0LL;
                                                              while ( 1 )
                                                              {
                                                                v45 = *(_QWORD *)&v53[2 * v40 + 216] & 0xBFFFFFFFFFFFFFFFLL;
                                                                if ( (unsigned int)sub_5A50(
                                                                                     xmmword_D6E0,
                                                                                     0xDu,
                                                                                     (int)v40 + 1,
                                                                                     &v44,
                                                                                     70,
                                                                                     (__int64)&v45) == -1 )
                                                                  return 0xFFFFFFFFLL;
                                                                if ( ++v40 >= nmemb )
                                                                  goto LABEL_50;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              return 0xFFFFFFFFLL;
                            }
                          }
                          return 0xFFFFFFFFLL;
                        }
                      }
                      return 0xFFFFFFFFLL;
                    }
                  }
                }
                else
                {
LABEL_54:
                  sub_4210((__int64)&v46);
                  if ( (unsigned int)sub_5A50(xmmword_D680, 5u, 0, &v44, 2, (unsigned int)v46) != -1
                    && (unsigned int)sub_5A50(xmmword_D680, 6u, 0, &v44, 2, DWORD2(v46)) != -1
                    && (unsigned int)sub_5A50(xmmword_D680, 0xDu, 0, &v44, 2, v47) != -1
                    && (unsigned int)sub_5A50(xmmword_D680, 0xEu, 0, &v44, 2, (unsigned int)v48) != -1
                    && (unsigned int)sub_5A50(xmmword_D680, 0xFu, 0, &v44, 2, v49[0]) != -1 )
                  {
                    if ( qword_10280 && (sub_4730(&v46), qword_10280) )
                    {
                      v10 = 0LL;
                      while ( (unsigned int)sub_5A50(
                                              xmmword_D620,
                                              6u,
                                              (int)v10 + 1,
                                              &v44,
                                              2,
                                              *((unsigned int *)&v46 + v10)) != -1 )
                      {
                        if ( ++v10 >= (unsigned __int64)qword_10280 )
                        {
                          if ( !qword_10280 )
                            goto LABEL_65;
                          v21 = 0LL;
                          while ( (unsigned int)sub_5A50(
                                                  xmmword_D620,
                                                  7u,
                                                  (int)v21 + 1,
                                                  &v44,
                                                  2,
                                                  *((unsigned int *)&v46 + v21 + 4)) != -1 )
                          {
                            if ( ++v21 >= (unsigned __int64)qword_10280 )
                            {
                              if ( !qword_10280 )
                                goto LABEL_65;
                              v23 = 0LL;
                              while ( (unsigned int)sub_5A50(
                                                      xmmword_D620,
                                                      8u,
                                                      (int)v23 + 1,
                                                      &v44,
                                                      2,
                                                      (unsigned int)v49[v23]) != -1 )
                              {
                                if ( ++v23 >= (unsigned __int64)qword_10280 )
                                {
                                  if ( !qword_10280 )
                                    goto LABEL_65;
                                  v26 = 0LL;
                                  while ( (unsigned int)sub_5A50(
                                                          xmmword_D620,
                                                          9u,
                                                          (int)v26 + 1,
                                                          &v44,
                                                          2,
                                                          (unsigned int)v51[v26]) != -1 )
                                  {
                                    if ( ++v26 >= (unsigned __int64)qword_10280 )
                                    {
                                      if ( !qword_10280 )
                                        goto LABEL_65;
                                      v29 = 0LL;
                                      while ( (unsigned int)sub_5A50(
                                                              xmmword_D620,
                                                              0xAu,
                                                              (int)v29 + 1,
                                                              &v44,
                                                              2,
                                                              (unsigned int)v52[v29]) != -1 )
                                      {
                                        if ( ++v29 >= (unsigned __int64)qword_10280 )
                                          goto LABEL_65;
                                      }
                                      return 0xFFFFFFFFLL;
                                    }
                                  }
                                  return 0xFFFFFFFFLL;
                                }
                              }
                              return 0xFFFFFFFFLL;
                            }
                          }
                          return 0xFFFFFFFFLL;
                        }
                      }
                    }
                    else
                    {
LABEL_65:
                      v11 = 1LL;
                      sub_4110(&v46);
                      while ( 1 )
                      {
                        __snprintf_chk(
                          v55,
                          16LL,
                          2LL,
                          16LL,
                          "%d.%02d",
                          *((_DWORD *)&v46 + v11 - 1) / 0x64u,
                          *((_DWORD *)&v46 + v11 - 1) % 0x64u);
                        if ( (unsigned int)sub_5A50(xmmword_D5C0, 3u, v11, &v44, 4, (__int64)v55) == -1 )
                          break;
                        if ( ++v11 == 4 )
                        {
                          v12 = 1LL;
                          while ( (unsigned int)sub_5A50(
                                                  xmmword_D5C0,
                                                  5u,
                                                  v12,
                                                  &v44,
                                                  2,
                                                  *((unsigned int *)&v46 + v12 - 1)) != -1 )
                          {
                            if ( ++v12 == 4 )
                            {
                              sub_4340(&v46);
                              if ( (unsigned int)sub_5A50(xmmword_D560, 0x32u, 0, &v44, 65, (unsigned int)v46) != -1
                                && (unsigned int)sub_5A50(xmmword_D560, 0x33u, 0, &v44, 65, DWORD2(v46)) != -1
                                && (unsigned int)sub_5A50(xmmword_D560, 0x34u, 0, &v44, 65, v47) != -1
                                && (unsigned int)sub_5A50(xmmword_D560, 0x35u, 0, &v44, 65, (unsigned int)v48) != -1
                                && (unsigned int)sub_5A50(xmmword_D560, 0x3Bu, 0, &v44, 65, v49[0]) != -1 )
                              {
                                return (unsigned int)-((unsigned int)sub_5A50(xmmword_D560, 0x3Cu, 0, &v44, 65, v50) == -1);
                              }
                              return 0xFFFFFFFFLL;
                            }
                          }
                          return 0xFFFFFFFFLL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  v5 = sub_4090();
  if ( (unsigned int)sub_5A50(xmmword_D740, 1u, 0, &v44, 67, v5) == -1 )
    return 0xFFFFFFFFLL;
  return 0LL;
}
// 2500: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 3FF0: using guessed type __int64 sub_3FF0(void);
// 4090: using guessed type __int64 sub_4090(void);
// D560: using guessed type __m128i xmmword_D560[6];
// D5C0: using guessed type __m128i xmmword_D5C0[6];
// D620: using guessed type __m128i xmmword_D620[6];
// D680: using guessed type __m128i xmmword_D680[6];
// D6E0: using guessed type __m128i xmmword_D6E0[6];
// D740: using guessed type __m128i xmmword_D740[6];
// D7A0: using guessed type __m128i xmmword_D7A0[6];
// D800: using guessed type __m128i xmmword_D800[6];
// D860: using guessed type __m128i xmmword_D860[6];
// D8C0: using guessed type __m128i xmmword_D8C0[6];
// D980: using guessed type __m128i xmmword_D980[6];
// 10280: using guessed type __int64 qword_10280;

//----- (0000000000008640) ----------------------------------------------------
_QWORD *__fastcall sub_8640(_QWORD *s2, unsigned __int64 *a2)
{
  unsigned __int64 v2; // rbp
  _QWORD *i; // rbx
  unsigned __int64 v4; // rdx
  _QWORD *v5; // r14

  v2 = *a2;
  if ( *a2 >= qword_10360 )
    return 0LL;
  for ( i = (_QWORD *)((char *)&unk_10380 + 120 * v2); ; i += 15 )
  {
    v4 = s2[10];
    v5 = i;
    if ( i[10] >= v4 && !memcmp(i, s2, 4 * v4) )
      break;
    *a2 = ++v2;
    if ( v2 >= qword_10360 )
      return 0LL;
  }
  return v5;
}
// 10360: using guessed type __int64 qword_10360;

//----- (00000000000086C0) ----------------------------------------------------
_DWORD *__fastcall sub_86C0(__int64 a1)
{
  _DWORD *v1; // rbx
  unsigned __int64 v2; // rbp

  if ( !qword_10360 )
    return 0LL;
  v1 = dword_10380;
  v2 = 0LL;
  while ( (int)sub_AEE0((__int64)v1, a1) <= 0 )
  {
    ++v2;
    v1 += 30;
    if ( v2 >= qword_10360 )
      return 0LL;
  }
  return v1;
}
// 10360: using guessed type __int64 qword_10360;
// 10380: using guessed type _DWORD dword_10380[44836];

//----- (0000000000008740) ----------------------------------------------------
__int64 __fastcall sub_8740(__int64 a1, unsigned __int64 a2, unsigned __int64 *a3, _DWORD *a4, _QWORD *a5)
{
  unsigned __int64 v8; // rdx
  int v9; // r10d
  __int64 v10; // rcx
  __int64 v12; // r11
  __int64 v13; // rcx
  unsigned __int8 v14; // al
  __int64 v15; // rcx
  unsigned __int64 v16; // rax

  v8 = *a3;
  if ( v8 >= a2 )
  {
    sub_B0F0(7u, 0, (__int64)"underflow for element type");
    goto LABEL_20;
  }
  v9 = *(unsigned __int8 *)(a1 + v8);
  if ( (unsigned __int8)v9 <= 0xA7u )
  {
    if ( (v9 & 0x80u) != 0 )
    {
      v12 = 0xEF00000007LL;
      if ( _bittest64(&v12, (unsigned int)(v9 - 128)) )
        goto LABEL_7;
    }
    else
    {
      if ( (_BYTE)v9 == 48 )
      {
LABEL_7:
        *a4 = v9;
        *a3 = v8 + 1;
        if ( v8 + 1 < a2 )
        {
          v10 = *(unsigned __int8 *)(a1 + v8 + 1);
          if ( (v10 & 0x80u) == 0LL )
          {
            *a5 = v10;
            ++*a3;
            return 0LL;
          }
          v13 = v10 & 0x7F;
          v14 = *(_BYTE *)(a1 + v8 + 1) & 0x7F;
          if ( v14 > 2u )
          {
            sub_B0F0(7u, 0, (__int64)"overflow for element length");
            goto LABEL_20;
          }
          v15 = v13 - 1;
          *a3 = v8 + 2;
          *a5 = 0LL;
          if ( !v14 )
            return 0LL;
          v16 = *a3;
          while ( v16 < a2 )
          {
            *a5 = (*a5 << 8) + *(unsigned __int8 *)(a1 + v16);
            v16 = *a3 + 1;
            *a3 = v16;
            if ( !v15 )
              return 0LL;
            v15 = 0LL;
          }
        }
        sub_B0F0(7u, 0, (__int64)"underflow for element length");
LABEL_20:
        *__errno_location() = 22;
        return 0xFFFFFFFFLL;
      }
      if ( (unsigned __int8)v9 > 0x30u )
      {
        if ( (unsigned __int8)(v9 - 65) <= 2u )
          goto LABEL_7;
      }
      else if ( (unsigned __int8)(v9 - 1) <= 5u )
      {
        goto LABEL_7;
      }
    }
  }
  sub_B0F0(7u, 0, (__int64)"unsupported element type %02X", *(unsigned __int8 *)(a1 + v8));
  *__errno_location() = 22;
  return 0xFFFFFFFFLL;
}

//----- (00000000000088B0) ----------------------------------------------------
_BYTE *__fastcall sub_88B0(_BYTE *a1, unsigned int a2)
{
  _BYTE *result; // rax
  char v3; // dl
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // edx

  result = a1 + 2;
  if ( a2 + 0x800000 > 0xFFFFFF )
  {
    v3 = 4;
    v4 = 3;
  }
  else if ( a2 + 0x8000 <= 0xFFFF )
  {
    v3 = 2 - (a2 + 128 < 0x100);
    v4 = a2 + 128 >= 0x100;
  }
  else
  {
    v3 = 3;
    v4 = 2;
  }
  *a1 = 2;
  v5 = 8 * v4;
  a1[1] = v3;
  do
  {
    ++result;
    v6 = a2 >> v5;
    v5 -= 8;
    *(result - 1) = v6;
  }
  while ( v5 != -8 );
  return result;
}

//----- (0000000000008930) ----------------------------------------------------
__int64 __fastcall sub_8930(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 result; // rax
  size_t v3; // rax
  int v4; // [rsp+4h] [rbp-24h] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-20h] BYREF
  size_t v6[3]; // [rsp+10h] [rbp-18h] BYREF

  v1 = *(_QWORD *)(a1 + 2080);
  v6[1] = __readfsqword(0x28u);
  result = 0LL;
  v5 = 0LL;
  v6[0] = 0LL;
  if ( v1 > 0x18 )
  {
    if ( (unsigned int)sub_8740(a1 + 30, v1, &v5, &v4, v6) != -1 )
    {
      if ( v4 == 48 )
      {
        if ( v6[0] )
        {
          v3 = *(_QWORD *)(a1 + 2080) - v5;
          if ( v3 >= v6[0] )
            return v3 == v6[0];
        }
      }
      sub_B0F0(7u, 0, (__int64)"Unexpected SNMP header type %02X length %zu", v4, v6[0]);
      *__errno_location() = 22;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000008A10) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_8A10(__int64 a1)
{
  unsigned __int64 *v1; // r14
  char *v2; // rbp
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rsi
  int v5; // ecx
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rsi
  __int64 v9; // rdx
  int v10; // eax
  __int64 v11; // rcx
  unsigned __int64 v12; // rsi
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rcx
  unsigned __int64 v16; // rsi
  __int64 v17; // rdx
  int v18; // eax
  __int64 v19; // rcx
  __int64 v20; // r8
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rsi
  unsigned int v23; // r10d
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r11
  unsigned __int64 v26; // r8
  __int64 v27; // rdi
  __int16 v28; // ax
  __int64 v29; // rsi
  int v30; // ecx
  unsigned __int64 v31; // rdx
  __int64 v32; // r10
  char *v33; // r8
  unsigned __int64 v34; // rcx
  int v35; // eax
  unsigned __int64 v36; // rcx
  __int64 v37; // rcx
  unsigned __int64 v38; // rdx
  int v40; // ecx
  bool v41; // cc
  unsigned __int64 v42; // r13
  const __m128i *v43; // r12
  __int64 *v44; // r15
  __m128i *v45; // rdx
  unsigned __int64 v46; // rax
  const __m128i *v47; // rax
  __m128i v48; // xmm0
  __m128i v49; // xmm1
  __m128i v50; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __int64 v53; // rax
  __m128i si128; // xmm5
  __int64 v55; // rdx
  unsigned __int64 v56; // r15
  __m128i v57; // xmm0
  unsigned __int64 v58; // rcx
  __m128i *v59; // rax
  const __m128i *v60; // rdx
  __m128i v61; // xmm1
  __m128i v62; // xmm2
  __m128i v63; // xmm3
  __m128i v64; // xmm4
  __m128i v65; // xmm5
  __m128i v66; // xmm6
  unsigned __int64 v67; // r13
  __int64 v68; // rbx
  __int64 v69; // r12
  size_t v70; // rdx
  unsigned __int64 v71; // r13
  unsigned __int64 v72; // rax
  unsigned __int64 v73; // r13
  unsigned __int64 v74; // rax
  char *v75; // rdi
  unsigned __int64 v76; // rdx
  char *v77; // rsi
  __int64 v78; // rax
  unsigned int v79; // ecx
  char v80; // al
  _BYTE *v81; // rcx
  _BYTE *v82; // rsi
  unsigned __int64 v83; // rdx
  __int64 v84; // rdi
  _BYTE *v85; // rcx
  unsigned int v86; // eax
  _BYTE *v87; // r9
  int v88; // ecx
  char *v89; // rax
  int v90; // eax
  char *v91; // rdx
  unsigned __int64 v92; // rdx
  char v93; // cl
  unsigned __int64 v94; // rax
  __int64 v95; // rdx
  unsigned int v96; // esi
  unsigned __int64 v97; // r10
  unsigned __int64 v98; // r8
  unsigned __int64 v99; // r9
  unsigned int v100; // esi
  unsigned __int64 v101; // rbx
  unsigned __int64 v102; // r8
  unsigned int v103; // esi
  unsigned __int64 v104; // r8
  __int64 v105; // r9
  __int64 v106; // r11
  __int64 v107; // r10
  unsigned __int64 v108; // rbx
  unsigned __int64 v109; // r13
  __int64 v110; // r12
  size_t v111; // rax
  unsigned __int64 v112; // r13
  _QWORD *v113; // rdx
  unsigned __int64 v114; // r10
  unsigned __int64 v115; // r13
  __int64 v116; // r9
  __int64 v117; // r10
  unsigned __int64 v118; // rax
  unsigned __int64 v119; // rdx
  __int64 v120; // rsi
  __int64 v121; // rcx
  size_t v122; // rbx
  char *v123; // rdx
  char *v124; // rdx
  __int64 v125; // rcx
  unsigned __int64 v126; // r13
  __int64 *v127; // rbx
  __m128i *v128; // r15
  __m128i v129; // xmm4
  __m128i v130; // xmm5
  __m128i v131; // xmm6
  __m128i v132; // xmm7
  __m128i v133; // xmm0
  __int64 v134; // rax
  __m128i v135; // xmm1
  __int64 v136; // rcx
  unsigned __int64 v137; // rax
  const __m128i *v138; // rax
  __int64 v139; // rcx
  __int64 v140; // rsi
  __m128i v141; // xmm2
  __m128i v142; // xmm3
  __m128i v143; // xmm4
  __m128i v144; // xmm5
  __m128i v145; // xmm6
  __int64 v146; // rax
  __m128i v147; // xmm7
  __int64 v148; // rcx
  __m128i v149; // xmm3
  __m128i v150; // xmm4
  __m128i v151; // xmm5
  __m128i v152; // xmm6
  __m128i v153; // xmm0
  __int64 v154; // rax
  __int64 v155; // rcx
  __m128i v156; // xmm2
  __m128i v157; // xmm3
  __m128i v158; // xmm4
  __m128i v159; // xmm5
  __m128i v160; // xmm6
  __m128i v161; // xmm7
  __int64 v162; // rax
  __m128i v163; // xmm0
  __int64 v164; // rcx
  unsigned __int64 v165; // r15
  const __m128i *v166; // r12
  __m128i *v167; // rdx
  unsigned __int64 v168; // rax
  const __m128i *v169; // rax
  __m128i v170; // xmm7
  __m128i v171; // xmm0
  __m128i v172; // xmm1
  __m128i v173; // xmm2
  __int64 v174; // rax
  __m128i v175; // xmm3
  __m128i v176; // xmm4
  __int64 v177; // rdx
  const char *v178; // r11
  __m128i *v179; // rcx
  __int64 v180; // rcx
  __int64 v181; // rax
  const char *v182; // rcx
  __int64 v183; // rcx
  char *v184; // rax
  const char *v185; // r8
  const char *v186; // rcx
  unsigned __int64 v187; // rax
  unsigned __int64 v188; // r13
  unsigned __int64 v189; // rbp
  int v190; // r15d
  unsigned __int64 v191; // r12
  __m128i *v192; // rax
  __int64 v193; // rax
  const __m128i *v194; // rsi
  __m128i v195; // xmm2
  __int64 v196; // rax
  __int64 v197; // rdx
  __m128i v198; // xmm5
  __m128i v199; // xmm6
  __m128i v200; // xmm7
  __m128i v201; // xmm0
  __m128i v202; // xmm1
  __int64 v203; // rax
  char *v204; // rax
  char *v205; // rax
  _BYTE *v206; // rcx
  int v207; // r12d
  const char *v208; // [rsp-FD0h] [rbp-3D000h]
  char *v209; // [rsp-FC8h] [rbp-3CFF8h]
  __int64 *v210; // [rsp-FC0h] [rbp-3CFF0h]
  unsigned __int64 *v211; // [rsp-FB8h] [rbp-3CFE8h]
  _QWORD *v212; // [rsp-FB0h] [rbp-3CFE0h]
  unsigned int v213; // [rsp-FA0h] [rbp-3CFD0h] BYREF
  int v214; // [rsp-F9Ch] [rbp-3CFCCh]
  unsigned __int64 v215; // [rsp-F98h] [rbp-3CFC8h] BYREF
  unsigned __int64 v216; // [rsp-F90h] [rbp-3CFC0h] BYREF
  _BYTE v217[1920]; // [rsp-F88h] [rbp-3CFB8h] BYREF
  _QWORD v218[252]; // [rsp-808h] [rbp-3C838h] BYREF
  __int64 v219; // [rsp-28h] [rbp-3C058h] BYREF
  __int64 v220; // [rsp-20h] [rbp-3C050h] BYREF
  _BYTE v221[4096]; // [rsp+0h] [rbp-3C030h] BYREF
  __int64 v222; // [rsp+1000h] [rbp-3B030h] BYREF
  unsigned __int64 v223; // [rsp+3BFE0h] [rbp-50h]
  unsigned __int64 v224; // [rsp+3BFF0h] [rbp-40h]

  while ( v221 != (_BYTE *)(&v222 - 30720) )
    ;
  v224 = __readfsqword(0x28u);
  v1 = (unsigned __int64 *)a1;
  v2 = (char *)(a1 + 30);
  v208 = (const char *)v218;
  memset(v218, 0, sizeof(v218));
  v210 = &v219;
  memset(&v219, 0, (size_t)&unk_3C010);
  v3 = *(_QWORD *)(a1 + 2080);
  v215 = 0LL;
  v216 = 0LL;
  if ( (unsigned int)sub_8740(a1 + 30, v3, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  if ( v213 != 48 || *(_QWORD *)(a1 + 2080) - v215 != v216 )
  {
    sub_B0F0(7u, 0, (__int64)"%s type %02X length %zu", "Unexpected SNMP header", v213, v216);
    goto LABEL_76;
  }
  if ( (unsigned int)sub_8740(a1 + 30, *(_QWORD *)(a1 + 2080), &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  if ( v213 != 2 || v216 != 1 )
  {
    sub_B0F0(7u, 0, (__int64)"Unexpected %s type %02X length %zu", "SNMP version", v213, v216);
    goto LABEL_76;
  }
  v4 = *(_QWORD *)(a1 + 2080);
  if ( !v4 || v215 >= v4 )
    goto LABEL_318;
  v214 = v2[v215] >> 31;
  v5 = (unsigned __int8)v2[v215++];
  HIDWORD(v218[8]) = v5 | (v214 << 8);
  if ( HIDWORD(v218[8]) > 1 )
  {
    sub_B0F0(7u, 0, (__int64)"Unsupported %s %d", "SNMP version", v5 | (v214 << 8));
    *__errno_location() = 22;
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)sub_8740(a1 + 30, v4, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  v6 = v216;
  if ( v213 != 4 || v216 > 0x3F )
  {
    sub_B0F0(7u, 0, (__int64)"Unexpected %s type %02X length %zu", "SNMP community", v213, v216);
    goto LABEL_76;
  }
  if ( v215 >= *(_QWORD *)(a1 + 2080) + 1 - v216 )
  {
    sub_B0F0(7u, 0, (__int64)"underflow for string");
    goto LABEL_76;
  }
  __snprintf_chk(v208, 64LL, 2LL, 64LL, "%.*s", v216, &v2[v215]);
  v215 += v6;
  if ( !LOBYTE(v218[0]) )
  {
    sub_B0F0(7u, 0, (__int64)"unsupported %s '%s'", "SNMP community", v208);
    *__errno_location() = 22;
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)sub_8740(a1 + 30, *(_QWORD *)(a1 + 2080), &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  v7 = *(_QWORD *)(a1 + 2080);
  if ( v7 - v215 != v216 )
  {
    sub_B0F0(7u, 0, (__int64)"%s type type %02X length %zu", "Unexpected SNMP request", v213, v216);
    goto LABEL_76;
  }
  LODWORD(v218[8]) = v213;
  if ( (unsigned int)sub_8740(a1 + 30, v7, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  if ( v213 != 2 || !v216 )
  {
    sub_B0F0(7u, 0, (__int64)"%s id type %02X length %zu", "Unexpected SNMP request", v213, v216);
    goto LABEL_76;
  }
  v8 = *(_QWORD *)(a1 + 2080);
  if ( v8 < v216 || v215 >= v8 - v216 + 1 )
  {
LABEL_318:
    sub_B0F0(7u, 0, (__int64)"underflow for integer");
    goto LABEL_76;
  }
  v9 = v215 + 1;
  v10 = *(char *)(a1 + v215 + 30) >> 31;
  v214 = v10;
  do
  {
    v10 = *(unsigned __int8 *)(a1 + v9 + 29) | (v10 << 8);
    v11 = v9++;
  }
  while ( v11 != v216 + v215 );
  v215 += v216;
  LODWORD(v218[9]) = v10;
  if ( (unsigned int)sub_8740(a1 + 30, v8, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  if ( v213 != 2 || !v216 )
  {
    sub_B0F0(7u, 0, (__int64)"%s state type %02X length %zu", "Unexpected SNMP error", v213, v216);
    goto LABEL_76;
  }
  v12 = *(_QWORD *)(a1 + 2080);
  if ( v12 < v216 || v215 >= v12 - v216 + 1 )
    goto LABEL_314;
  v13 = v215 + 1;
  v14 = 0;
  do
  {
    v14 = *(unsigned __int8 *)(a1 + v13 + 29) | (v14 << 8);
    v15 = v13++;
  }
  while ( v15 != v216 + v215 );
  v215 += v216;
  HIDWORD(v218[9]) = v14;
  if ( (unsigned int)sub_8740(a1 + 30, v12, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  if ( v213 != 2 || !v216 )
  {
    sub_B0F0(7u, 0, (__int64)"%s index type %02X length %zu", "Unexpected SNMP error", v213, v216);
    goto LABEL_76;
  }
  v16 = *(_QWORD *)(a1 + 2080);
  if ( v16 < v216 || v215 >= v16 - v216 + 1 )
  {
LABEL_314:
    sub_B0F0(7u, 0, (__int64)"underflow for unsigned");
    goto LABEL_76;
  }
  v17 = v215 + 1;
  v18 = 0;
  do
  {
    v18 = *(unsigned __int8 *)(a1 + v17 + 29) | (v18 << 8);
    v19 = v17++;
  }
  while ( v19 != v216 + v215 );
  v215 += v216;
  LODWORD(v209) = v213;
  LODWORD(v218[10]) = v18;
  if ( (unsigned int)sub_8740(a1 + 30, v16, &v215, &v213, &v216) == -1 )
    return 0xFFFFFFFFLL;
  v20 = v213;
  v21 = v216;
  if ( v213 != 48 || (v22 = *(_QWORD *)(a1 + 2080), v23 = (unsigned int)v209, v22 - v215 != v216) )
  {
LABEL_243:
    sub_B0F0(7u, 0, (__int64)"%s type %02X length %zu", "Unexpected SNMP varbindings", v20, v21);
    goto LABEL_76;
  }
  v218[251] = 0LL;
  if ( v215 < v22 )
  {
    LODWORD(v211) = (_DWORD)v209;
    while ( 1 )
    {
      if ( (unsigned int)sub_8740((__int64)v2, v22, &v215, &v213, &v216) == -1 )
        return 0xFFFFFFFFLL;
      v20 = v213;
      v21 = v216;
      if ( v213 != 48 || !v216 )
        goto LABEL_243;
      if ( (unsigned int)sub_8740((__int64)v2, v1[260], &v215, &v213, &v216) == -1 )
        return 0xFFFFFFFFLL;
      v24 = v216;
      if ( v213 != 6 || !v216 )
      {
        sub_B0F0(7u, 0, (__int64)"%s OID type %02X length %zu", "Unexpected SNMP varbindings", v213, v216);
        goto LABEL_76;
      }
      v25 = v1[260];
      v26 = v215;
      v27 = v218[251];
      if ( v215 >= v25 + 1 - v216 )
      {
        sub_B0F0(7u, 0, (__int64)"underflow for oid");
        goto LABEL_76;
      }
      LOWORD(v218[12 * v218[251] + 22]) = v216;
      if ( v24 > 0xFFFF )
      {
        sub_B0F0(3u, 0, (__int64)"could not decode: internal error");
        return 0xFFFFFFFFLL;
      }
      v28 = v24 + 4;
      if ( v24 <= 0xFF )
        v28 = (v24 > 0x7F) + (_WORD)v24 + 2;
      v29 = 12 * v27;
      LOWORD(v218[v29 + 22]) = v28;
      v218[v29 + 21] = 0LL;
      v30 = (unsigned __int8)v2[v26];
      if ( (v30 & 0x80u) != 0 )
      {
        sub_B0F0(7u, 0, (__int64)"unsupported OID startbyte %02X", v30);
        *__errno_location() = 22;
        return 0xFFFFFFFFLL;
      }
      v218[12 * v27 + 21] = 2LL;
      v215 = v26 + 1;
      LODWORD(v218[12 * v27 + 11]) = (unsigned __int8)v30 / 0x28u;
      HIDWORD(v218[12 * v27 + 11]) = (unsigned __int8)v30 % 0x28u;
      v31 = v24 - 1;
      if ( v31 )
        break;
LABEL_67:
      if ( (unsigned int)sub_8740((__int64)v2, v25, &v215, &v213, &v216) == -1 )
        return 0xFFFFFFFFLL;
      if ( v213 == 5 )
      {
        if ( v216 )
        {
LABEL_95:
          sub_B0F0(7u, 0, (__int64)"%s value type %02X length %zu", "Unexpected SNMP varbindings", v213, v216);
          goto LABEL_76;
        }
      }
      else if ( !v216 )
      {
        goto LABEL_95;
      }
      v22 = v1[260];
      if ( v215 >= v22 + 1LL - (int)v216 )
      {
        sub_B0F0(7u, 0, (__int64)"underflow for ptr");
        goto LABEL_76;
      }
      v215 += (int)v216;
      v38 = ++v218[251];
      if ( v215 >= v22 )
      {
        v23 = (unsigned int)v211;
        goto LABEL_79;
      }
      if ( v38 > 0x13 )
      {
        sub_B0F0(7u, 0, (__int64)"Overflow in OID list", v37, v213);
        goto LABEL_66;
      }
    }
    v32 = 2LL;
    v33 = (char *)&v208[96 * v27 + 96];
    do
    {
      v34 = v215;
      *(_DWORD *)v33 = 0;
      --v31;
      v35 = v2[v34] & 0x7F;
      *(_DWORD *)v33 = v35;
      if ( v2[v34] < 0 )
      {
        if ( !v31 )
          goto LABEL_75;
        v209 = v2;
        while ( 1 )
        {
          ++v34;
          --v31;
          v35 = (*((_BYTE *)v1 + v34 + 30) & 0x7F) + (v35 << 7);
          if ( *((char *)v1 + v34 + 30) >= 0 )
            break;
          if ( !v31 )
          {
            v215 = v34;
            *(_DWORD *)v33 = v35;
LABEL_75:
            sub_B0F0(7u, 0, (__int64)"underflow for OID byte");
LABEL_76:
            *__errno_location() = 22;
            return 0xFFFFFFFFLL;
          }
        }
        *(_DWORD *)v33 = v35;
        v2 = v209;
      }
      v36 = v34 + 1;
      ++v32;
      v33 += 4;
      v215 = v36;
      v218[12 * v27 + 21] = v32;
      if ( !v31 )
        goto LABEL_67;
    }
    while ( v32 != 20 );
    sub_B0F0(7u, 0, (__int64)"overflow for OID byte", v36, v33);
LABEL_66:
    *__errno_location() = 14;
    return 0xFFFFFFFFLL;
  }
LABEL_79:
  if ( HIDWORD(v218[8]) == 1 )
  {
    if ( strcmp(s1, v208) )
    {
      v219 = 6LL;
      goto LABEL_97;
    }
    v40 = v218[8];
    v41 = SLODWORD(v218[8]) <= 163;
    if ( LODWORD(v218[8]) != 163 )
      goto LABEL_82;
    v23 = 6;
LABEL_196:
    v219 = v23;
    goto LABEL_97;
  }
  if ( dword_4CCE8 )
  {
    v219 = 5LL;
    goto LABEL_97;
  }
  v40 = v218[8];
  v41 = SLODWORD(v218[8]) <= 163;
  if ( LODWORD(v218[8]) == 163 )
  {
    if ( HIDWORD(v218[8]) )
      v23 = 6;
    goto LABEL_196;
  }
LABEL_82:
  if ( v41 )
  {
    if ( v40 != 160 )
    {
      if ( v40 == 161 )
      {
        v42 = 0LL;
        v43 = (const __m128i *)&v218[11];
        v44 = v210;
        if ( v218[251] )
        {
          while ( 1 )
          {
            v47 = (const __m128i *)sub_86C0((__int64)v43);
            if ( v47 )
            {
              if ( v223 > 0x7FF )
                goto LABEL_260;
              v45 = (__m128i *)&v44[15 * v223 + 1];
              *v45 = _mm_loadu_si128(v47);
              v45[1] = _mm_loadu_si128(v47 + 1);
              v45[2] = _mm_loadu_si128(v47 + 2);
              v45[3] = _mm_loadu_si128(v47 + 3);
              v45[4] = _mm_loadu_si128(v47 + 4);
              v45[5] = _mm_loadu_si128(v47 + 5);
              v45[6] = _mm_loadu_si128(v47 + 6);
              v45[7].m128i_i64[0] = v47[7].m128i_i64[0];
              v46 = v223 + 1;
            }
            else
            {
              if ( !HIDWORD(v218[8]) )
              {
                LODWORD(v219) = 2;
                HIDWORD(v219) = v42;
                goto LABEL_97;
              }
              if ( v223 > 0x7FF )
              {
LABEL_260:
                v182 = "Failed handling SNMP GETNEXT: value list overflow\n";
                goto LABEL_256;
              }
              v48 = _mm_loadu_si128(v43 + 1);
              v49 = _mm_loadu_si128(v43 + 2);
              v50 = _mm_loadu_si128(v43 + 3);
              v51 = _mm_loadu_si128(v43 + 4);
              v52 = _mm_loadu_si128(v43 + 5);
              v53 = 120 * v223;
              si128 = _mm_load_si128(&off_FAE0);
              v55 = (__int64)&v44[15 * v223 + 1];
              *(__m128i *)v55 = _mm_loadu_si128(v43);
              *(__m128i *)(v55 + 16) = v48;
              *(__m128i *)(v55 + 32) = v49;
              *(__m128i *)(v55 + 48) = v50;
              *(__m128i *)(v55 + 64) = v51;
              *(__m128i *)(v55 + 80) = v52;
              *(_QWORD *)&v221[v53 + 80] = (char *)&dword_0 + 2;
              *(__m128i *)&v221[v53 + 64] = si128;
              v46 = v223 + 1;
            }
            v223 = v46;
            ++v42;
            v43 += 6;
            if ( v42 >= v218[251] )
              goto LABEL_219;
          }
        }
        if ( (_DWORD)v219 )
        {
LABEL_295:
          v223 = 0LL;
LABEL_296:
          v95 = 2076LL;
          v93 = 0;
          v94 = 2046LL;
          v67 = 2048LL;
LABEL_145:
          *((_BYTE *)v1 + v94 + 30) = 48;
          *((_BYTE *)v1 + v95 + 1) = v93;
          v96 = HIDWORD(v219);
          if ( (unsigned int)(HIDWORD(v219) + 0x800000) > 0xFFFFFF )
          {
            sub_88B0((_BYTE *)v1 + v67 + 22, HIDWORD(v219));
            v100 = v219;
            if ( (unsigned int)(v219 + 0x800000) > 0xFFFFFF )
            {
              sub_88B0((_BYTE *)v1 + v67 + 16, v219);
              v103 = v218[9];
              if ( (unsigned int)(LODWORD(v218[9]) + 0x800000) > 0xFFFFFF )
              {
                v101 = 6LL;
                goto LABEL_157;
              }
LABEL_154:
              v101 = 5LL;
              if ( v103 + 0x8000 <= 0xFFFF )
                v101 = (v103 + 128 > 0xFF) + 3LL;
LABEL_156:
              if ( v102 < v101 )
              {
                v185 = "ID overflow";
                goto LABEL_303;
              }
LABEL_157:
              sub_88B0((_BYTE *)v1 + v102 - v101 + 30, v103);
              v108 = v101 + v107 + v106 + v105 - v67 + 2048;
              if ( v108 > 0xFFFF )
              {
                if ( v104 > 0x7FF )
                {
                  v109 = v104 - 2048;
                  v110 = 2048LL;
                  goto LABEL_162;
                }
              }
              else if ( v108 > 0xFF )
              {
                if ( v104 > 3 )
                {
                  v181 = (__int64)v1 + v104 + 26;
                  v109 = v104 - 4;
                  v110 = 4LL;
                  *((_BYTE *)v1 + v104 + 26) = -94;
                  *(_BYTE *)(v181 + 1) = -126;
                  *(_WORD *)(v181 + 2) = __ROL2__(v108, 8);
                  goto LABEL_162;
                }
              }
              else
              {
                if ( v108 <= 0x7F )
                {
                  if ( v104 > 1 )
                  {
                    v109 = v104 - 2;
                    v110 = 2LL;
                    *((_BYTE *)v1 + v104 + 28) = -94;
                    *((_BYTE *)v1 + v104 + 29) = v108;
                    goto LABEL_162;
                  }
                  goto LABEL_302;
                }
                if ( v104 > 2 )
                {
                  v203 = (__int64)v1 + v104 + 27;
                  v109 = v104 - 3;
                  v110 = 3LL;
                  *((_BYTE *)v1 + v104 + 27) = -94;
                  *(_BYTE *)(v203 + 1) = -127;
                  *(_BYTE *)(v203 + 2) = v108;
LABEL_162:
                  v111 = strlen(v208);
                  if ( v111 > 0xFF )
                  {
                    if ( v109 < v111 + 4 )
                      goto LABEL_312;
                    v112 = v109 - (v111 + 4);
                    v183 = (__int64)v1 + v112 + 30;
                    *(_BYTE *)v183 = 4;
                    v113 = (unsigned __int64 *)((char *)v1 + v112 + 34);
                    *(_BYTE *)(v183 + 1) = -126;
                    *(_WORD *)(v183 + 2) = __ROL2__(v111, 8);
                  }
                  else
                  {
                    if ( v111 <= 0x7F )
                    {
                      if ( v109 >= v111 + 2 )
                      {
                        v112 = v109 - (v111 + 2);
                        *((_BYTE *)v1 + v112 + 30) = 4;
                        *((_BYTE *)v1 + v112 + 31) = v111;
                        v113 = (unsigned __int64 *)((char *)v1 + v112 + 32);
                        goto LABEL_166;
                      }
LABEL_312:
                      v185 = "COMMUNITY overflow";
                      goto LABEL_303;
                    }
                    if ( v109 < v111 + 3 )
                      goto LABEL_312;
                    v112 = v109 - (v111 + 3);
                    v206 = (char *)v1 + v112 + 30;
                    *v206 = 4;
                    v113 = (unsigned __int64 *)((char *)v1 + v112 + 33);
                    v206[1] = -127;
                    v206[2] = v111;
                  }
LABEL_166:
                  if ( (unsigned int)v111 >= 8 )
                  {
                    *v113 = v218[0];
                    v178 = v208;
                    *(_QWORD *)((char *)v113 + (unsigned int)v111 - 8) = *(_QWORD *)&v208[(unsigned int)v111 - 8];
                    qmemcpy(
                      (void *)((unsigned __int64)(v113 + 1) & 0xFFFFFFFFFFFFFFF8LL),
                      (const void *)(v178 - ((const char *)v113 - ((unsigned __int64)(v113 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
                      8LL * (((unsigned int)v111 + (_DWORD)v113 - (((_DWORD)v113 + 8) & 0xFFFFFFF8)) >> 3));
                  }
                  else if ( (v111 & 4) != 0 )
                  {
                    *(_DWORD *)v113 = v218[0];
                    *(_DWORD *)((char *)v113 + (unsigned int)v111 - 4) = *(_DWORD *)&v208[(unsigned int)v111 - 4];
                  }
                  else if ( (_DWORD)v111 )
                  {
                    *(_BYTE *)v113 = v218[0];
                    if ( (v111 & 2) != 0 )
                      *(_WORD *)((char *)v113 + (unsigned int)v111 - 2) = *(_WORD *)&v208[(unsigned int)v111 - 2];
                  }
                  v114 = 6LL;
                  if ( (unsigned int)(HIDWORD(v218[8]) + 0x800000) <= 0xFFFFFF )
                  {
                    v114 = 5LL;
                    if ( (unsigned int)(HIDWORD(v218[8]) + 0x8000) <= 0xFFFF )
                      v114 = ((unsigned int)(HIDWORD(v218[8]) + 128) > 0xFF) + 3LL;
                  }
                  if ( v112 < v114 )
                  {
                    v185 = "VERSION overflow";
                    goto LABEL_303;
                  }
                  v115 = v112 - v114;
                  sub_88B0((_BYTE *)v1 + v115 + 30, HIDWORD(v218[8]));
                  v118 = v117 + v116 + v108 + v110;
                  if ( v118 > 0xFFFF )
                  {
                    if ( v115 > 0x7FF )
                    {
                      v120 = (__int64)v1 + v115 - 2018;
                      v122 = v118 + 2048;
                      if ( v115 == 2048 )
                        goto LABEL_181;
                      goto LABEL_239;
                    }
                  }
                  else if ( v118 > 0xFF )
                  {
                    if ( v115 > 3 )
                    {
                      v120 = (__int64)v1 + v115 + 26;
                      v119 = v115 - 4;
                      *((_BYTE *)v1 + v115 + 26) = 48;
                      *(_WORD *)(v120 + 2) = __ROL2__(v118, 8);
                      v121 = 4LL;
                      *(_BYTE *)(v120 + 1) = -126;
                      goto LABEL_180;
                    }
                  }
                  else
                  {
                    if ( v118 <= 0x7F )
                    {
                      if ( v115 > 1 )
                      {
                        v119 = v115 - 2;
                        v120 = (__int64)v1 + v115 + 28;
                        v121 = 2LL;
                        *((_BYTE *)v1 + v115 + 28) = 48;
                        *((_BYTE *)v1 + v115 + 29) = v118;
                        goto LABEL_180;
                      }
                      goto LABEL_309;
                    }
                    if ( v115 > 2 )
                    {
                      v120 = (__int64)v1 + v115 + 27;
                      v119 = v115 - 3;
                      v121 = 3LL;
                      *((_BYTE *)v1 + v115 + 27) = 48;
                      *(_BYTE *)(v120 + 1) = -127;
                      *(_BYTE *)(v120 + 2) = v118;
LABEL_180:
                      v122 = v118 + v121;
                      if ( !v119 )
                      {
LABEL_181:
                        v1[260] = v122;
                        return 0LL;
                      }
LABEL_239:
                      memmove(v2, (const void *)v120, v122);
                      goto LABEL_181;
                    }
                  }
LABEL_309:
                  v185 = "RESPONSE overflow";
                  goto LABEL_303;
                }
              }
LABEL_302:
              v185 = "PDU overflow";
LABEL_303:
              v186 = "SNMP response";
              goto LABEL_262;
            }
            v98 = v67 - 8;
            if ( (unsigned int)(v219 + 0x8000) > 0xFFFF )
            {
              v99 = 5LL;
              goto LABEL_153;
            }
            goto LABEL_151;
          }
          if ( (unsigned int)(HIDWORD(v219) + 0x8000) > 0xFFFF )
          {
            v97 = 5LL;
            goto LABEL_149;
          }
          goto LABEL_147;
        }
LABEL_220:
        v56 = v223;
        if ( v223 )
          goto LABEL_103;
        goto LABEL_296;
      }
LABEL_248:
      sub_B0F0(3u, 0, (__int64)"UNHANDLED REQUEST TYPE %d", v40);
      v122 = 0LL;
      goto LABEL_181;
    }
    if ( v218[251] )
    {
      v209 = v2;
      v126 = 0LL;
      v127 = v210;
      v128 = (__m128i *)&v218[11];
      do
      {
        v216 = 0LL;
        v138 = (const __m128i *)sub_8640(v128, &v216);
        if ( v138 )
        {
          if ( v216 >= qword_10360 )
          {
            if ( !HIDWORD(v218[8]) )
              goto LABEL_285;
            if ( v223 > 0x7FF )
              goto LABEL_284;
            v129 = _mm_loadu_si128(v128 + 1);
            v130 = _mm_loadu_si128(v128 + 2);
            v131 = _mm_loadu_si128(v128 + 3);
            v132 = _mm_loadu_si128(v128 + 4);
            v133 = _mm_loadu_si128(v128 + 5);
            v134 = 120 * v223;
            v135 = _mm_load_si128(&off_FB20);
            v136 = (__int64)&v127[15 * v223 + 1];
            *(__m128i *)v136 = _mm_loadu_si128(v128);
            *(__m128i *)(v136 + 16) = v129;
            *(__m128i *)(v136 + 32) = v130;
            *(__m128i *)(v136 + 48) = v131;
            *(__m128i *)(v136 + 64) = v132;
            *(__m128i *)(v136 + 80) = v133;
            *(_QWORD *)&v221[v134 + 80] = (char *)&dword_0 + 2;
            *(__m128i *)&v221[v134 + 64] = v135;
            v137 = v223 + 1;
          }
          else
          {
            v139 = v128[5].m128i_i64[0];
            v140 = v138[5].m128i_i64[0];
            if ( v140 == v139 + 1 )
            {
              if ( !HIDWORD(v218[8]) )
              {
LABEL_285:
                LODWORD(v219) = 2;
                v2 = v209;
                HIDWORD(v219) = v126;
                goto LABEL_97;
              }
              if ( v223 > 0x7FF )
              {
LABEL_284:
                v182 = "Failed handling SNMP GET: value list overflow\n";
                goto LABEL_256;
              }
              v157 = _mm_loadu_si128(v128 + 1);
              v158 = _mm_loadu_si128(v128 + 2);
              v159 = _mm_loadu_si128(v128 + 3);
              v160 = _mm_loadu_si128(v128 + 4);
              v161 = _mm_loadu_si128(v128 + 5);
              v162 = 120 * v223;
              v163 = _mm_load_si128(&off_FB00);
              v164 = (__int64)&v127[15 * v223 + 1];
              *(__m128i *)v164 = _mm_loadu_si128(v128);
              *(__m128i *)(v164 + 16) = v157;
              *(__m128i *)(v164 + 32) = v158;
              *(__m128i *)(v164 + 48) = v159;
              *(__m128i *)(v164 + 64) = v160;
              *(__m128i *)(v164 + 80) = v161;
              *(_QWORD *)&v221[v162 + 80] = (char *)&dword_0 + 2;
              *(__m128i *)&v221[v162 + 64] = v163;
              v137 = v223 + 1;
            }
            else if ( v140 == v139 )
            {
              if ( v223 > 0x7FF )
                goto LABEL_284;
              v179 = (__m128i *)&v127[15 * v223 + 1];
              *v179 = _mm_loadu_si128(v138);
              v179[1] = _mm_loadu_si128(v138 + 1);
              v179[2] = _mm_loadu_si128(v138 + 2);
              v179[3] = _mm_loadu_si128(v138 + 3);
              v179[4] = _mm_loadu_si128(v138 + 4);
              v179[5] = _mm_loadu_si128(v138 + 5);
              v179[6] = _mm_loadu_si128(v138 + 6);
              v179[7].m128i_i64[0] = v138[7].m128i_i64[0];
              v137 = v223 + 1;
            }
            else
            {
              if ( !HIDWORD(v218[8]) )
                goto LABEL_285;
              if ( v223 > 0x7FF )
                goto LABEL_284;
              v141 = _mm_loadu_si128(v128 + 1);
              v142 = _mm_loadu_si128(v128 + 2);
              v143 = _mm_loadu_si128(v128 + 3);
              v144 = _mm_loadu_si128(v128 + 4);
              v145 = _mm_loadu_si128(v128 + 5);
              v146 = 120 * v223;
              v147 = _mm_load_si128(&off_FB20);
              v148 = (__int64)&v127[15 * v223 + 1];
              *(__m128i *)v148 = _mm_loadu_si128(v128);
              *(__m128i *)(v148 + 16) = v141;
              *(__m128i *)(v148 + 32) = v142;
              *(__m128i *)(v148 + 48) = v143;
              *(__m128i *)(v148 + 64) = v144;
              *(__m128i *)(v148 + 80) = v145;
              *(_QWORD *)&v221[v146 + 80] = (char *)&dword_0 + 2;
              *(__m128i *)&v221[v146 + 64] = v147;
              v137 = v223 + 1;
            }
          }
        }
        else
        {
          if ( !HIDWORD(v218[8]) )
            goto LABEL_285;
          if ( v223 > 0x7FF )
            goto LABEL_284;
          v149 = _mm_loadu_si128(v128 + 1);
          v150 = _mm_loadu_si128(v128 + 2);
          v151 = _mm_loadu_si128(v128 + 3);
          v152 = _mm_loadu_si128(v128 + 4);
          v153 = _mm_loadu_si128(v128 + 5);
          v154 = 120 * v223;
          v155 = (__int64)&v127[15 * v223 + 1];
          *(__m128i *)v155 = _mm_loadu_si128(v128);
          v156 = _mm_load_si128(&off_FB20);
          *(__m128i *)(v155 + 16) = v149;
          *(__m128i *)(v155 + 32) = v150;
          *(__m128i *)(v155 + 48) = v151;
          *(__m128i *)(v155 + 64) = v152;
          *(__m128i *)(v155 + 80) = v153;
          *(_QWORD *)&v221[v154 + 80] = (char *)&dword_0 + 2;
          *(__m128i *)&v221[v154 + 64] = v156;
          v137 = v223 + 1;
        }
        v223 = v137;
        ++v126;
        v128 += 6;
      }
      while ( v126 < v218[251] );
      v2 = v209;
    }
LABEL_219:
    if ( (_DWORD)v219 )
      goto LABEL_97;
    goto LABEL_220;
  }
  if ( v40 != 165 )
    goto LABEL_248;
  v165 = 0LL;
  v212 = &v218[11];
  v166 = (const __m128i *)&v218[11];
  qmemcpy(v217, &v218[11], sizeof(v217));
  if ( !v218[251] )
  {
LABEL_263:
    v187 = v218[251];
    v188 = 0LL;
    if ( LODWORD(v218[10]) )
    {
      v209 = v2;
      v211 = v1;
      do
      {
        v189 = HIDWORD(v218[9]);
        if ( HIDWORD(v218[9]) >= v187 )
          break;
        v190 = 0;
        v191 = 12LL * HIDWORD(v218[9]);
        do
        {
          v194 = (const __m128i *)sub_86C0((__int64)&v217[v191 * 8]);
          if ( v194 )
          {
            if ( v223 > 0x7FF )
              goto LABEL_255;
            v192 = (__m128i *)&v210[15 * v223 + 1];
            *v192 = _mm_loadu_si128(v194);
            v192[1] = _mm_loadu_si128(v194 + 1);
            v192[2] = _mm_loadu_si128(v194 + 2);
            v192[3] = _mm_loadu_si128(v194 + 3);
            v192[4] = _mm_loadu_si128(v194 + 4);
            v192[5] = _mm_loadu_si128(v194 + 5);
            v192[6] = _mm_loadu_si128(v194 + 6);
            v192[7].m128i_i64[0] = v194[7].m128i_i64[0];
            v193 = 1920LL;
            ++v223;
            if ( v191 >= 240 )
              v193 = v191 * 8;
            ++v190;
            ((void (__fastcall *)(_BYTE *, const __m128i *, __int64, unsigned __int64))__memcpy_chk)(
              &v217[v191 * 8],
              v194,
              96LL,
              v193 - v191 * 8);
          }
          else
          {
            if ( !HIDWORD(v218[8]) )
            {
              v207 = v189;
              v1 = v211;
              v2 = v209;
              LODWORD(v219) = 2;
              HIDWORD(v219) = v207;
              goto LABEL_97;
            }
            if ( v223 > 0x7FF )
              goto LABEL_255;
            v195 = _mm_load_si128(&off_FAE0);
            v196 = 120 * v223;
            v197 = (__int64)&v210[15 * v223 + 1];
            v198 = _mm_loadu_si128((const __m128i *)&v212[v191 + 2]);
            v199 = _mm_loadu_si128((const __m128i *)&v212[v191 + 4]);
            v200 = _mm_loadu_si128((const __m128i *)&v212[v191 + 6]);
            v201 = _mm_loadu_si128((const __m128i *)&v212[v191 + 8]);
            v202 = _mm_loadu_si128((const __m128i *)&v212[v191 + 10]);
            *(__m128i *)v197 = _mm_loadu_si128((const __m128i *)&v212[v191]);
            *(__m128i *)(v197 + 16) = v198;
            *(__m128i *)(v197 + 32) = v199;
            *(__m128i *)(v197 + 48) = v200;
            *(__m128i *)(v197 + 64) = v201;
            *(__m128i *)(v197 + 80) = v202;
            *(_QWORD *)&v221[v196 + 80] = (char *)&dword_0 + 2;
            *(__m128i *)&v221[v196 + 64] = v195;
            ++v223;
          }
          v187 = v218[251];
          ++v189;
          v191 += 12LL;
        }
        while ( v189 < v218[251] );
        if ( !v190 )
          break;
        ++v188;
      }
      while ( v188 < LODWORD(v218[10]) );
      v2 = v209;
      v1 = v211;
    }
    goto LABEL_219;
  }
  while ( 1 )
  {
    if ( v165 >= HIDWORD(v218[9]) )
      goto LABEL_263;
    v169 = (const __m128i *)sub_86C0((__int64)&v217[96 * v165]);
    if ( !v169 )
      break;
    if ( v223 > 0x7FF )
      goto LABEL_255;
    v167 = (__m128i *)&v210[15 * v223 + 1];
    *v167 = _mm_loadu_si128(v169);
    v167[1] = _mm_loadu_si128(v169 + 1);
    v167[2] = _mm_loadu_si128(v169 + 2);
    v167[3] = _mm_loadu_si128(v169 + 3);
    v167[4] = _mm_loadu_si128(v169 + 4);
    v167[5] = _mm_loadu_si128(v169 + 5);
    v167[6] = _mm_loadu_si128(v169 + 6);
    v167[7].m128i_i64[0] = v169[7].m128i_i64[0];
    v168 = v223 + 1;
LABEL_230:
    v223 = v168;
    ++v165;
    v166 += 6;
    if ( v165 >= v218[251] )
      goto LABEL_263;
  }
  if ( HIDWORD(v218[8]) )
  {
    if ( v223 > 0x7FF )
    {
LABEL_255:
      v182 = "Failed handling SNMP GETBULK: value list overflow\n";
LABEL_256:
      sub_B0F0(3u, 0, (__int64)"%s", v182);
      return 0xFFFFFFFFLL;
    }
    v170 = _mm_loadu_si128(v166 + 1);
    v171 = _mm_loadu_si128(v166 + 2);
    v172 = _mm_loadu_si128(v166 + 3);
    v173 = _mm_loadu_si128(v166 + 4);
    v174 = 120 * v223;
    v175 = _mm_loadu_si128(v166 + 5);
    v176 = _mm_load_si128(&off_FAE0);
    v177 = (__int64)&v210[15 * v223 + 1];
    *(__m128i *)v177 = _mm_loadu_si128(v166);
    *(__m128i *)(v177 + 16) = v170;
    *(__m128i *)(v177 + 32) = v171;
    *(__m128i *)(v177 + 48) = v172;
    *(__m128i *)(v177 + 64) = v173;
    *(__m128i *)(v177 + 80) = v175;
    *(_QWORD *)&v221[v174 + 80] = (char *)&dword_0 + 2;
    *(__m128i *)&v221[v174 + 64] = v176;
    v168 = v223 + 1;
    goto LABEL_230;
  }
  LODWORD(v219) = 2;
  HIDWORD(v219) = v165;
LABEL_97:
  v56 = v218[251];
  if ( v218[251] > 0x800uLL )
  {
    v185 = "value list overflow";
    goto LABEL_303;
  }
  if ( !v218[251] )
    goto LABEL_295;
  v57 = _mm_load_si128(&off_FB40);
  v58 = 0LL;
  v59 = (__m128i *)&v220;
  v60 = (const __m128i *)&v218[11];
  do
  {
    v61 = _mm_loadu_si128(v60);
    v62 = _mm_loadu_si128(v60 + 1);
    ++v58;
    v59[7].m128i_i64[0] = (__int64)&dword_0 + 2;
    v63 = _mm_loadu_si128(v60 + 2);
    v64 = _mm_loadu_si128(v60 + 3);
    v59[6] = v57;
    v60 += 6;
    v65 = _mm_loadu_si128(v60 - 2);
    v66 = _mm_loadu_si128(v60 - 1);
    *v59 = v61;
    v59 = (__m128i *)((char *)v59 + 120);
    *(__m128i *)((char *)v59 - 104) = v62;
    *(__m128i *)((char *)v59 - 88) = v63;
    *(__m128i *)((char *)v59 - 72) = v64;
    *(__m128i *)((char *)v59 - 56) = v65;
    *(__m128i *)((char *)v59 - 40) = v66;
  }
  while ( v58 < v56 && v58 != 20 );
  v223 = v56;
LABEL_103:
  v209 = (char *)v1;
  v67 = 2048LL;
  v68 = (__int64)&v210[15 * v56 - 15];
  v69 = 30 * v56 - 30;
  while ( 2 )
  {
    v70 = *(__int16 *)(v68 + 120);
    --v56;
    if ( v67 < v70 )
    {
      v205 = sub_AD90(v68 + 8);
      v185 = "DATA overflow";
      v186 = v205;
      goto LABEL_262;
    }
    v71 = v67 - v70;
    memcpy(&v2[v71], *(const void **)(v68 + 104), v70);
    v72 = *(__int16 *)(v68 + 96);
    if ( v71 < v72 )
    {
      v204 = sub_AD90(v68 + 8);
      v185 = "OID overflow";
      v186 = v204;
      goto LABEL_262;
    }
    v73 = v71 - v72;
    v74 = *(_QWORD *)(v68 + 88);
    v75 = &v2[v73];
    if ( v74 <= 2 )
    {
      *v75 = 6;
      v80 = 1;
      goto LABEL_186;
    }
    v76 = 1LL;
    v77 = (char *)&v218[251] + 4 * v69 + 4 * v74;
    v78 = v68;
    while ( 2 )
    {
      while ( 2 )
      {
        v79 = *(_DWORD *)(v78 + 16);
        if ( v79 > 0xFFFFFFF )
        {
          v76 += 5LL;
          goto LABEL_109;
        }
        if ( v79 <= 0x1FFFFF )
        {
          if ( v79 <= 0x3FFF )
            v76 += (v79 > 0x7F) + 1LL;
          else
            v76 += 3LL;
LABEL_109:
          v78 += 4LL;
          if ( (char *)v78 == v77 )
            goto LABEL_113;
          continue;
        }
        break;
      }
      v78 += 4LL;
      v76 += 4LL;
      if ( (char *)v78 != v77 )
        continue;
      break;
    }
LABEL_113:
    *v75 = 6;
    if ( v76 > 0xFFFF )
    {
      v89 = sub_AD90(v68 + 8);
      sub_B0F0(3u, 0, (__int64)"could not encode '%s': OID overflow", v89);
      goto LABEL_135;
    }
    v80 = v76;
    if ( v76 > 0xFF )
    {
      v75[1] = -126;
      v81 = v75 + 4;
      *((_WORD *)v75 + 1) = __ROL2__(v76, 8);
    }
    else
    {
      if ( v76 > 0x7F )
      {
        v75[1] = -127;
        v81 = v75 + 3;
        v75[2] = v76;
        goto LABEL_117;
      }
LABEL_186:
      v75[1] = v80;
      v81 = v75 + 2;
    }
LABEL_117:
    v82 = v81 + 1;
    v83 = 2LL;
    *v81 = *(_BYTE *)(v68 + 12) + 40 * *(_BYTE *)(v68 + 8);
    if ( *(_QWORD *)(v68 + 88) > 2uLL )
    {
      while ( 1 )
      {
        v86 = *(_DWORD *)(v68 + 4 * v83 + 8);
        if ( v86 > 0xFFFFFFF )
        {
          v84 = 4LL;
          goto LABEL_126;
        }
        if ( v86 > 0x1FFFFF )
        {
          v84 = 3LL;
          goto LABEL_126;
        }
        if ( v86 > 0x3FFF )
          break;
        if ( v86 > 0x7F )
        {
          v84 = 1LL;
LABEL_126:
          v87 = v82;
          v88 = 7 * v84;
          do
          {
            *v87++ = (v86 >> v88) | 0x80;
            v88 -= 7;
          }
          while ( v88 );
          goto LABEL_123;
        }
        v84 = 0LL;
LABEL_123:
        v85 = &v82[v84];
        v82 += v84 + 1;
        ++v83;
        *v85 = v86 & 0x7F;
        if ( v83 >= *(_QWORD *)(v68 + 88) )
          goto LABEL_135;
      }
      v84 = 2LL;
      goto LABEL_126;
    }
LABEL_135:
    v90 = *(__int16 *)(v68 + 120) + *(__int16 *)(v68 + 96);
    if ( (unsigned __int64)v90 > 0xFFFF )
    {
      if ( v73 <= 0x7FF )
        goto LABEL_261;
      v67 = v73 - 2048;
      goto LABEL_140;
    }
    if ( (unsigned __int64)v90 > 0xFF )
    {
      if ( v73 <= 3 )
        goto LABEL_261;
      v67 = v73 - 4;
      v123 = &v2[v67];
      *(_WORD *)v123 = -32208;
      *((_WORD *)v123 + 1) = __ROL2__(v90, 8);
      goto LABEL_140;
    }
    if ( (unsigned __int64)v90 > 0x7F )
    {
      if ( v73 <= 2 )
        goto LABEL_261;
      v67 = v73 - 3;
      v124 = &v2[v67];
      *(_WORD *)v124 = -32464;
      v124[2] = v90;
LABEL_140:
      v68 -= 120LL;
      v69 -= 30LL;
      if ( v56 )
        continue;
      v1 = (unsigned __int64 *)v209;
      v92 = 2048 - v67;
      if ( 2048 - v67 > 0xFFFF )
      {
        v94 = v67 - 2048;
      }
      else
      {
        if ( v92 <= 0xFF )
        {
          v93 = -(char)v67;
          if ( v92 <= 0x7F )
          {
            v94 = v67 - 2;
            v95 = v67 + 28;
            goto LABEL_145;
          }
          v180 = (__int64)&v209[v67 + 27];
          v94 = v67 - 3;
          v209[v67 + 27] = 48;
          *(_BYTE *)(v180 + 2) = -(char)v67;
          *(_BYTE *)(v180 + 1) = -127;
          v96 = HIDWORD(v219);
          if ( (unsigned int)(HIDWORD(v219) + 0x800000) > 0xFFFFFF )
          {
            v97 = 6LL;
            goto LABEL_149;
          }
LABEL_200:
          v97 = 5LL;
          if ( v96 + 0x8000 <= 0xFFFF )
LABEL_147:
            v97 = (v96 + 128 > 0xFF) + 3LL;
LABEL_148:
          if ( v94 < v97 )
          {
            v185 = "ERROR INDEX overflow";
            goto LABEL_303;
          }
LABEL_149:
          sub_88B0((_BYTE *)v1 + v94 - v97 + 30, v96);
          v100 = v219;
          if ( (unsigned int)(v219 + 0x800000) > 0xFFFFFF || (v99 = 5LL, (unsigned int)(v219 + 0x8000) > 0xFFFF) )
          {
LABEL_152:
            if ( v98 < v99 )
            {
              v185 = "ERROR STATUS overflow";
              goto LABEL_303;
            }
LABEL_153:
            v101 = 6LL;
            sub_88B0((_BYTE *)v1 + v98 - v99 + 30, v100);
            v103 = v218[9];
            if ( (unsigned int)(LODWORD(v218[9]) + 0x800000) > 0xFFFFFF )
              goto LABEL_156;
            goto LABEL_154;
          }
LABEL_151:
          v99 = (v100 + 128 > 0xFF) + 3LL;
          goto LABEL_152;
        }
        if ( v67 <= 3 )
        {
          v185 = "VARBINDS overflow";
          goto LABEL_303;
        }
        v125 = (__int64)&v209[v67 + 26];
        v94 = v67 - 4;
        v209[v67 + 26] = 48;
        *(_BYTE *)(v125 + 1) = -126;
        *(_WORD *)(v125 + 2) = __ROL2__(v92, 8);
      }
      v96 = HIDWORD(v219);
      v97 = 6LL;
      if ( (unsigned int)(HIDWORD(v219) + 0x800000) > 0xFFFFFF )
        goto LABEL_148;
      goto LABEL_200;
    }
    break;
  }
  if ( v73 > 1 )
  {
    v67 = v73 - 2;
    v91 = &v2[v67];
    *v91 = 48;
    v91[1] = v90;
    goto LABEL_140;
  }
LABEL_261:
  v184 = sub_AD90(v68 + 8);
  v185 = "VARBIND overflow";
  v186 = v184;
LABEL_262:
  sub_B0F0(3u, 0, (__int64)"Failed encoding %s: %s", v186, v185);
  return 0xFFFFFFFFLL;
}
// 9195: positive sp value 3B000 has been found
// 9135: variable 'v37' is possibly undefined
// 9781: variable 'v98' is possibly undefined
// 9781: variable 'v99' is possibly undefined
// 97D6: variable 'v102' is possibly undefined
// 97ED: variable 'v107' is possibly undefined
// 97E9: variable 'v106' is possibly undefined
// 97E9: variable 'v105' is possibly undefined
// 9823: variable 'v104' is possibly undefined
// 9907: variable 'v117' is possibly undefined
// 9904: variable 'v116' is possibly undefined
// 0: using guessed type int dword_0;
// 2500: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// FAE0: using guessed type __m128i off_FAE0;
// FB00: using guessed type __m128i off_FB00;
// FB20: using guessed type __m128i off_FB20;
// FB40: using guessed type __m128i off_FB40;
// 10360: using guessed type __int64 qword_10360;
// 4CCE8: using guessed type int dword_4CCE8;

//----- (000000000000A870) ----------------------------------------------------
int __fastcall sub_A870(const char *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // r13
  __int64 v6; // rbp
  char *v7; // rbx
  const unsigned __int16 **v8; // r14
  const unsigned __int16 *v9; // rax
  const char *v10; // r12
  __int64 v11; // r11
  char v12; // si
  char v13; // si
  __int64 v14; // rdx
  __int64 v15; // r13
  __int64 v16; // rdx
  __int64 *v17; // rbp
  char v21; // [rsp+1Fh] [rbp-259h]
  FILE *stream; // [rsp+20h] [rbp-258h]
  char v24[520]; // [rsp+30h] [rbp-248h] BYREF
  unsigned __int64 v25; // [rsp+238h] [rbp-40h]

  v25 = __readfsqword(0x28u);
  if ( a1 )
  {
    if ( a2 )
    {
      stream = fopen(a1, "r");
      if ( stream )
      {
        while ( 1 )
        {
LABEL_4:
          if ( !fgets(v24, 512, stream) )
            return fclose(stream);
          if ( !a3 )
            continue;
          v4 = a2;
          v5 = 0LL;
          v21 = v24[0];
          v6 = v24[0];
          while ( 1 )
          {
            v7 = *(char **)v4;
            if ( !*(_QWORD *)v4 )
              goto LABEL_30;
            v8 = __ctype_b_loc();
            v9 = *v8;
            if ( ((*v8)[v6] & 0x2000) != 0 )
            {
              v10 = v24;
              do
              {
                v11 = *++v10;
                v12 = v11;
              }
              while ( (v9[v11] & 0x2000) != 0 );
            }
            else
            {
              v12 = v21;
              v10 = v24;
            }
            if ( !v12 )
              goto LABEL_30;
            while ( 1 )
            {
              v13 = *v7;
              if ( !*v7 )
                break;
              ++v10;
              ++v7;
              if ( *(v10 - 1) != v13 )
                goto LABEL_30;
            }
            v14 = *v10;
            if ( (_BYTE)v14 == 58 )
              break;
            if ( (v9[v14] & 0x2000) != 0 )
              goto LABEL_17;
LABEL_30:
            ++v5;
            v4 += 208LL;
            if ( a3 == v5 )
              goto LABEL_4;
          }
          ++v10;
LABEL_17:
          if ( a4 )
          {
            --a4;
            goto LABEL_30;
          }
          v15 = 0LL;
          if ( *(_QWORD *)(v4 + 8) )
          {
            if ( (v9[*v10] & 0x2000) != 0 )
            {
              do
LABEL_20:
                v16 = *++v10;
              while ( (v9[v16] & 0x2000) != 0 );
              v17 = *(__int64 **)(v4 + 8 * v15 + 16);
              if ( !v17 )
                goto LABEL_24;
            }
            else
            {
              while ( 1 )
              {
                v17 = *(__int64 **)(v4 + 8 * v15 + 16);
                if ( v17 )
                  break;
                do
                {
                  ++v10;
LABEL_24:
                  ;
                }
                while ( (v9[*v10] & 0x2000) == 0 );
                if ( (unsigned __int64)++v15 >= *(_QWORD *)(v4 + 8) )
                  goto LABEL_4;
                if ( (v9[*v10] & 0x2000) != 0 )
                  goto LABEL_20;
              }
            }
            *v17 = strtoll(v10, 0LL, 0);
            v9 = *v8;
            goto LABEL_24;
          }
        }
      }
    }
  }
  return -1;
}

//----- (000000000000AAB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_AAB0(const char *a1, const char *a2)
{
  char *v2; // rax
  char *v3; // rbx
  size_t v4; // rax
  const char *v5; // rbx
  const unsigned __int16 **v6; // rax
  const unsigned __int16 *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  unsigned __int64 result; // rax

  v2 = strstr(a1, a2);
  if ( !v2 )
    return 0LL;
  v3 = v2;
  v4 = strlen(a2);
  v5 = &v3[v4 + (v3[v4] == 58)];
  v6 = __ctype_b_loc();
  v7 = *v6;
  v8 = *v5;
  if ( ((*v6)[v8] & 0x2000) != 0 )
  {
    do
    {
      v9 = *++v5;
      LOBYTE(v8) = v9;
    }
    while ( (v7[v9] & 0x2000) != 0 );
  }
  result = 0LL;
  if ( (_BYTE)v8 )
    return strtoul(v5, 0LL, 0);
  return result;
}

//----- (000000000000AB50) ----------------------------------------------------
size_t __fastcall sub_AB50(char *a1, const char *a2, _DWORD *a3, int a4)
{
  __int64 v4; // r13
  char *v6; // rax
  char *v7; // rbx
  size_t result; // rax
  char *v9; // rbx
  _DWORD *v10; // rbx
  const unsigned __int16 **v11; // r12
  char *v12; // rdi
  const unsigned __int16 *v13; // rsi
  char *v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  char *endptr; // [rsp+8h] [rbp-30h] BYREF

  v4 = a4;
  endptr = a1;
  v6 = strstr(a1, a2);
  if ( !v6 )
    return (size_t)memset(a3, 0, 4LL * (int)v4);
  v7 = v6;
  result = strlen(a2);
  v9 = &v7[result];
  endptr = v9;
  if ( *v9 == 58 )
    endptr = v9 + 1;
  if ( (int)v4 > 0 )
  {
    v10 = &a3[v4];
    v11 = __ctype_b_loc();
    do
    {
      v12 = endptr;
      v13 = *v11;
      v14 = endptr + 1;
      v15 = *endptr;
      if ( ((*v11)[v15] & 0x2000) != 0 )
      {
        do
        {
          endptr = v14;
          v16 = *v14;
          v12 = v14++;
          LOBYTE(v15) = v16;
        }
        while ( (v13[v16] & 0x2000) != 0 );
      }
      result = 0LL;
      if ( (_BYTE)v15 )
        result = strtoul(v12, &endptr, 0);
      *a3++ = result;
    }
    while ( v10 != a3 );
  }
  return result;
}

//----- (000000000000AC30) ----------------------------------------------------
__int64 sub_AC30(_DWORD *a1, __int64 a2, ...)
{
  FILE *v2; // rax
  FILE *v3; // rbx
  unsigned int v4; // r13d
  gcc_va_list va; // [rsp+8h] [rbp-200h] BYREF
  char filename[264]; // [rsp+20h] [rbp-1E8h] BYREF
  unsigned __int64 v8; // [rsp+128h] [rbp-E0h]

  va_start(va, a2);
  v8 = __readfsqword(0x28u);
  __vsnprintf_chk(filename, 256LL, 2LL, 256LL, a2, va);
  v2 = fopen(filename, "r");
  v3 = v2;
  if ( v2 )
  {
    v4 = -1;
    if ( fgets(filename, 256, v2) )
    {
      v4 = 0;
      *a1 = strtoul(filename, 0LL, 0);
    }
    fclose(v3);
  }
  else
  {
    return (unsigned int)-1;
  }
  return v4;
}
// 2820: using guessed type __int64 __fastcall __vsnprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000AD90) ----------------------------------------------------
char *__fastcall sub_AD90(__int64 a1)
{
  bool v1; // zf
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rbp

  v1 = *(_QWORD *)(a1 + 80) == 0LL;
  byte_4CD60[0] = 0;
  if ( !v1 )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      v2 += (int)__snprintf_chk(&byte_4CD60[v2], 202 - v2, 2LL, 202 - v2, ".%u", *(_DWORD *)(a1 + 4 * v3));
      if ( v2 > 0xC9 )
        break;
      ++v3;
    }
    while ( v3 < *(_QWORD *)(a1 + 80) );
  }
  return byte_4CD60;
}
// 2500: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);

//----- (000000000000AE10) ----------------------------------------------------
int *__fastcall sub_AE10(char *a1)
{
  char v1; // al
  unsigned __int64 v2; // rdx
  int v3; // eax
  char *v5[3]; // [rsp+0h] [rbp-18h] BYREF

  v5[1] = (char *)__readfsqword(0x28u);
  v5[0] = a1;
  if ( a1 )
  {
    qword_4CD50 = 0LL;
    v1 = *a1;
    if ( *a1 )
    {
      v2 = 0LL;
      while ( v1 == 46 )
      {
        if ( v2 > 0x13 )
          break;
        v5[0] = a1 + 1;
        if ( !a1[1] )
          break;
        v3 = strtoul(a1 + 1, v5, 0);
        a1 = v5[0];
        v2 = qword_4CD50 + 1;
        dword_4CD00[qword_4CD50] = v3;
        qword_4CD50 = v2;
        v1 = *a1;
        if ( !*a1 )
        {
          if ( v2 > 1 && (unsigned int)(dword_4CD04 + 40 * dword_4CD00[0]) <= 0xFF )
            return dword_4CD00;
          return 0LL;
        }
      }
    }
  }
  return 0LL;
}
// 4CD00: using guessed type int dword_4CD00[];
// 4CD04: using guessed type int dword_4CD04;
// 4CD50: using guessed type __int64 qword_4CD50;

//----- (000000000000AEE0) ----------------------------------------------------
__int64 __fastcall sub_AEE0(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // r8
  __int64 v4; // rdx
  int v6; // eax
  int v7; // r9d

  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(a2 + 80);
  v4 = 0LL;
  while ( 1 )
  {
    if ( v2 == v4 )
    {
      if ( v2 < v3 && *(_DWORD *)(a2 + 4 * v2) != -1 )
        return 2 * (unsigned int)(*(_DWORD *)(a2 + 4 * v2) < -1) - 1;
      return 0LL;
    }
    v6 = *(_DWORD *)(a1 + 4 * v4);
    if ( v3 == v4 )
    {
      if ( v6 != -1 )
        return (v6 >> 31) | 1u;
      return 0LL;
    }
    v7 = *(_DWORD *)(a2 + 4 * v4);
    if ( (v7 & v6) == 0xFFFFFFFF )
      return 0LL;
    if ( v6 > v7 )
      return 1LL;
    if ( v6 < v7 )
      break;
    if ( ++v4 == 20 )
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000000AF60) ----------------------------------------------------
__int64 __fastcall sub_AF60(const char *a1, const char *a2, __int64 a3, int a4)
{
  char *v6; // rax
  char *v7; // r13
  char *v8; // rax
  __int64 v9; // rbx

  v6 = strdup(a1);
  if ( v6 )
  {
    v7 = v6;
    v8 = strtok(v6, a2);
    if ( v8 )
    {
      v9 = 0LL;
      do
      {
        while ( a4 <= (int)v9 )
        {
          v8 = strtok(0LL, a2);
          if ( !v8 )
            goto LABEL_7;
        }
        *(_QWORD *)(a3 + 8 * v9) = strdup(v8);
        v9 = (int)v9 + 1;
        v8 = strtok(0LL, a2);
      }
      while ( v8 );
    }
    else
    {
      LODWORD(v9) = 0;
    }
LABEL_7:
    free(v7);
  }
  else
  {
    LODWORD(v9) = 0;
  }
  return (unsigned int)v9;
}

//----- (000000000000B000) ----------------------------------------------------
__int64 sub_B000()
{
  __int64 v0; // r9
  __int64 v1; // r8
  __int64 v2; // rax
  __int64 v3; // rcx

  if ( !qword_4C380 )
    return 0LL;
  v0 = 0LL;
  v1 = 0LL;
  v2 = 0LL;
  v3 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    if ( v3 > **((_QWORD **)&unk_4C3A0 + v2) )
    {
      v3 = **((_QWORD **)&unk_4C3A0 + v2);
      v0 = v2;
      v1 = 1LL;
    }
    ++v2;
  }
  while ( qword_4C380 != v2 );
  if ( v1 )
    return *((_QWORD *)&unk_4C3A0 + v0);
  else
    return 0LL;
}
// B000: using guessed type __int64 sub_B000();
// 4C380: using guessed type __int64 qword_4C380;

//----- (000000000000B070) ----------------------------------------------------
__int64 __fastcall sub_B070(char *s2)
{
  int v1; // r13d
  __int64 v2; // rbx

  if ( (int)nmemb <= 0 )
    return 0xFFFFFFFFLL;
  v1 = nmemb;
  v2 = 0LL;
  do
  {
    if ( !strcmp(*((const char **)&unk_4CC60 + v2), s2) )
      return (unsigned int)v2;
    ++v2;
  }
  while ( v1 > (int)v2 );
  return 0xFFFFFFFFLL;
}

//----- (000000000000B0F0) ----------------------------------------------------
__int64 sub_B0F0(unsigned int a1, int a2, __int64 a3, ...)
{
  int v4; // r14d
  int v6; // eax
  int v7; // r13d
  __int64 v8; // rsi
  char *v9; // rax
  int v10; // r10d
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  __int16 v13; // dx
  signed __int64 v14; // rdx
  void *v15; // rsp
  signed __int64 v16; // rdx
  void *v17; // rsp
  int v18; // r14d
  char *v19; // rax
  unsigned __int64 v20; // rcx
  char v22[4]; // [rsp+8h] [rbp-110h] BYREF
  int v23; // [rsp+Ch] [rbp-10Ch]
  unsigned __int64 v24; // [rsp+10h] [rbp-108h]
  gcc_va_list va; // [rsp+18h] [rbp-100h] BYREF
  unsigned __int64 v26; // [rsp+30h] [rbp-E8h]

  v26 = __readfsqword(0x28u);
  v4 = 0;
  if ( (unsigned __int8)(a1 & 7) <= dword_10288 )
  {
    va_start(va, a3);
    v6 = __vsnprintf_chk(0LL, 0LL, 2LL, -1LL, a3, va);
    v7 = v6;
    if ( v6 >= 0 )
    {
      if ( a2 > 0 )
      {
        v9 = strerror(a2);
        v10 = v7 + strlen(v9) + 3;
        v11 = v10 + 23LL;
        v12 = v11 & 0xFFFFFFFFFFFFF000LL;
        v13 = v11 & 0xFFF0;
        while ( v22 != &v22[-v12] )
          ;
        v16 = v13 & 0xFFF;
        v17 = alloca(v16);
        if ( v16 )
          *(_QWORD *)&v22[v16 - 8] = *(_QWORD *)&v22[v16 - 8];
        va_end(va);
        va_start(va, a3);
        v23 = v10;
        v24 = v10;
        v18 = __vsnprintf_chk(v22, v10, 2LL, v10, a3, va);
        if ( v18 >= 0 )
        {
          v19 = strerror(a2);
          v20 = v24;
          if ( v18 >= v24 )
            v20 = v18;
          v4 = __snprintf_chk(&v22[v18], v23 - v18, 2LL, v20 - v18, ": %s", v19) + v18;
          if ( dword_4CCE4 )
            goto LABEL_15;
          return (unsigned int)__fprintf_chk(stderr, 2LL, "%s\n", v22);
        }
      }
      else
      {
        v8 = v6 + 3;
        while ( v22 != &v22[-((v8 + 23) & 0xFFFFFFFFFFFFF000LL)] )
          ;
        v14 = ((_WORD)v6 + 26) & 0xFF0;
        v15 = alloca(v14);
        if ( (((_WORD)v6 + 26) & 0xFF0) != 0 )
          *(_QWORD *)&v22[v14 - 8] = *(_QWORD *)&v22[v14 - 8];
        va_end(va);
        va_start(va, a3);
        v4 = __vsnprintf_chk(v22, v8, 2LL, v8, a3, va);
        if ( v4 >= 0 )
        {
          if ( dword_4CCE4 )
          {
LABEL_15:
            __syslog_chk(a1, 2LL, "%s", v22);
            return (unsigned int)v4;
          }
          return (unsigned int)__fprintf_chk(stderr, 2LL, "%s\n", v22);
        }
      }
    }
    return (unsigned int)-1;
  }
  return (unsigned int)v4;
}
// 2500: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 2820: using guessed type __int64 __fastcall __vsnprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2880: using guessed type __int64 __syslog_chk(_QWORD, _QWORD, const char *, ...);
// 2930: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 10288: using guessed type int dword_10288;
// 10300: using guessed type __int64 stderr;
// 4CCE4: using guessed type int dword_4CCE4;

//----- (000000000000B440) ----------------------------------------------------
void *__fastcall sub_B440(size_t a1)
{
  void *v1; // rbx
  int *v3; // rax

  v1 = malloc(a1);
  if ( !v1 )
  {
    v3 = __errno_location();
    sub_B0F0(7u, *v3, (__int64)"Failed allocating memory");
  }
  return v1;
}

//----- (000000000000B480) ----------------------------------------------------
__int64 __fastcall sub_B480(const char *a1, void *a2, __int64 a3)
{
  FILE *v4; // rax
  FILE *v5; // rbx
  size_t v6; // rbp
  int v7; // eax
  int *v9; // rax
  int *v10; // rax

  v4 = fopen(a1, "r");
  if ( v4 )
  {
    v5 = v4;
    v6 = fread(a2, 1uLL, a3 - 1, v4);
    v7 = fclose(v5);
    if ( v6 && v7 != -1 )
    {
      *((_BYTE *)a2 + v6) = 0;
      return 0LL;
    }
    v9 = __errno_location();
    sub_B0F0(4u, *v9, (__int64)"Failed reading %s", a1);
  }
  else
  {
    v10 = __errno_location();
    sub_B0F0(4u, *v10, (__int64)"Failed opening %s", a1);
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000000B530) ----------------------------------------------------
__int64 __fastcall sub_B530(__time_t *a1, struct timeval *a2)
{
  __time_t tv_sec; // rax
  __suseconds_t tv_usec; // rcx
  __suseconds_t v5; // rsi
  float v6; // xmm0_4
  __int64 result; // rax
  int *v8; // rax

  if ( gettimeofday(a2, 0LL) == -1 )
  {
    v8 = __errno_location();
    sub_B0F0(4u, *v8, (__int64)"could not get ticks");
    return 0xFFFFFFFFLL;
  }
  tv_sec = a2->tv_sec;
  if ( a2->tv_sec < *a1 || (tv_usec = a2->tv_usec, v5 = a1[1], a2->tv_sec == *a1) && tv_usec < v5 )
  {
    sub_B0F0(4u, 0, (__int64)"could not get ticks: time running backwards");
    return 0xFFFFFFFFLL;
  }
  v6 = (float)(int)(tv_sec - 1 - *a1) * 100.0 + (float)(int)((tv_usec + 1000000 - v5) / 10000);
  if ( v6 < -2147483600.0 )
    return 0x80000000LL;
  result = 0x7FFFFFFFLL;
  if ( v6 <= 2147483600.0 )
    return (unsigned int)(int)v6;
  return result;
}

//----- (000000000000B640) ----------------------------------------------------
void sub_B640()
{
  if ( ptr )
  {
    if ( getpid() == dword_4CE38 )
    {
      unlink(ptr);
      free(ptr);
      ptr = 0LL;
    }
  }
}
// 4CE38: using guessed type int dword_4CE38;

//----- (000000000000B6A0) ----------------------------------------------------
__int64 __fastcall sub_B6A0(const char *a1)
{
  const char *v1; // rbx
  __pid_t v2; // ebp
  int v3; // r12d
  FILE *v4; // rax
  FILE *v5; // rbx
  int *v7; // rax
  int v8; // ebp
  int *v9; // rbx
  int *v10; // rax
  int v11; // r12d
  int *v12; // rbp
  int *v13; // rax
  int v14; // ebp
  int *v15; // rbx

  v1 = a1;
  if ( !a1 )
    v1 = ident;
  v2 = getpid();
  if ( ptr )
  {
    if ( !access(ptr, 4) && dword_4CE38 == v2 )
    {
      utimensat(0, ptr, 0LL, 0);
      return 0LL;
    }
    v3 = 1;
    free(ptr);
    ptr = 0LL;
    qword_4CE30 = 0LL;
    if ( *v1 != 47 )
    {
LABEL_7:
      if ( (unsigned int)__asprintf_chk(&ptr, 2LL, "%s/%s.pid", off_102C0, v1) == -1 )
        return 0xFFFFFFFFLL;
      goto LABEL_8;
    }
  }
  else
  {
    v3 = 0;
    if ( *v1 != 47 )
      goto LABEL_7;
  }
  if ( (unsigned int)__asprintf_chk(&ptr, 2LL, "%s", v1) == -1 )
    return 0xFFFFFFFFLL;
LABEL_8:
  v4 = fopen(ptr, "w");
  v5 = v4;
  if ( v4 )
  {
    if ( (int)__fprintf_chk(v4, 2LL, "%ld\n", v2) <= 0 || fflush(v5) )
    {
      v10 = __errno_location();
      v11 = *v10;
      v12 = v10;
      fclose(v5);
      unlink(ptr);
      free(ptr);
      ptr = 0LL;
      *v12 = v11;
    }
    else
    {
      fclose(v5);
      qword_4CE30 = (__int64)ptr;
      if ( v3 )
        return 0LL;
      dword_4CE38 = v2;
      if ( sub_B8E0((void (*)(void *))sub_B640) >= 0 )
        return 0LL;
      v7 = __errno_location();
      v8 = *v7;
      v9 = v7;
      unlink(ptr);
      free(ptr);
      ptr = 0LL;
      dword_4CE38 = 0;
      *v9 = v8;
    }
  }
  else
  {
    v13 = __errno_location();
    v14 = *v13;
    v15 = v13;
    free(ptr);
    ptr = 0LL;
    *v15 = v14;
  }
  return 0xFFFFFFFFLL;
}
// 26D0: using guessed type __int64 __asprintf_chk(_QWORD, _QWORD, const char *, ...);
// 2930: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 102C0: using guessed type char *off_102C0;
// 4CE30: using guessed type __int64 qword_4CE30;
// 4CE38: using guessed type int dword_4CE38;

//----- (000000000000B8E0) ----------------------------------------------------
int __fastcall sub_B8E0(void (*a1)(void *))
{
  return _cxa_atexit(a1, 0LL, lpdso_handle);
}

//----- (000000000000B8F4) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=284 queued=131 decompiled=131 lumina nreq=0 worse=0 better=0
// ALL OK, 131 function(s) have been successfully decompiled
